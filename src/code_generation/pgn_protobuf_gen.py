# -------------------------------------------------------------------------------
# Name:        pgn_protobuf_gen
# Purpose:     Protobuf messages generator for pgn supporting classes
#
# Author:      Laurent Carré
#
# Created:     12/12/2023
# Copyright:   (c) Laurent Carré Sterwen Technology 2021-2023
# Licence:     Eclipse Public License 2.0
# -------------------------------------------------------------------------------


import logging
import datetime


from code_generation.nmea2000_meta import BitFieldAttributeDef, RepeatAttributeDef, ScalarAttributeDef, NMEA2000Meta
from router_common import Typedef

_logger = logging.getLogger("ShipDataServer." + __name__)

scalar_type_association = { Typedef.UINT: {1: 'uint32', 2: 'uint32', 3: 'uint32', 4: 'uint32', 8: 'uint64'},
                            Typedef.INT: {1: 'int32', 2: 'int32', 3: 'int32', 4: 'int32', 8: 'int64'},
                            Typedef.FLOAT: {1: 'float', 2: 'float', 3: 'float', 4: 'float', 8: 'double'}
                            }

other_type_association = {Typedef.STRING: 'string', Typedef.BYTES: 'bytes'}


class ProtobufPGNGenerator:

    def __init__(self, output_file):
        try:
            self._of = open(output_file, 'w')
        except IOError as err:
            _logger.error("Protobuf code generator - error opening output file %s:%s" % (output_file, err))
            raise
        _logger.info(f"Generating Protobuf code in {output_file}")
        self._of.write('//   Protobuf code generated by NMEA message router application (c) Sterwen Technology 2023\n')
        self._of.write('//   generated on %s\n' % datetime.datetime.now().strftime("%Y-%M-%d:%H:%M"))
        self._of.write('//   do not modify code\n\n\n')
        self._of.write('syntax = "proto3";\n\n')

    def close(self):
        self._of.close()

    def gen_messages(self, class_def_list: list):
        for cls in class_def_list:
            self.gen_pgn_message(cls)

    def gen_pgn_message(self, class_def: NMEA2000Meta):
        self._of.write(f'message {class_def.class_name}Pb'' {'f'  // {class_def.name}\n')
        if class_def.repeat_field_set is not None:
            self._of.write(f'\tmessage {class_def.repeat_field_set.class_name}Pb'' {\n')
            self.gen_attributes(class_def.repeat_field_set, '\t\t')
            self._of.write('\t}\n')

        field_number = self.gen_attributes(class_def, '\t')
        if class_def.repeat_field_set is not None:
            self._of.write(f'\trepeated {class_def.repeat_field_set.class_name}Pb {class_def.repeat_field_set.method} = {field_number};\n')
        self._of.write('}\n\n')

    def gen_attributes(self, class_def: NMEA2000Meta, tabs):
        field_number = 1
        for attr in class_def.attributes:
            if isinstance(attr, (ScalarAttributeDef, BitFieldAttributeDef)):
                try:
                    pb_type = scalar_type_association[attr.typedef][attr.byte_length]
                except KeyError:
                    _logger.error(f"Wrong protobuf type for {attr.method} in PGN {class_def.class_name}")
                    continue
            elif isinstance(attr, RepeatAttributeDef):
                continue
            else:
                try:
                    pb_type = other_type_association[attr.typedef]
                except KeyError:
                    _logger.error(f"Wrong protobuf type for {attr.method} in PGN {class_def.class_name}")
                    continue
            self._of.write(f'{tabs}{pb_type} {attr.method} = {field_number};\n')
            field_number += 1
        return field_number









