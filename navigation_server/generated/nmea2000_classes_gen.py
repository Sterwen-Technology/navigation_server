#   Python code generated by NMEA message router application (c) Sterwen Technology 2023
#   generated on 2025-02-07:15:16
#   do not modify code


import struct

from navigation_server.router_common import N2KInvalidMessageException, get_global_enum
from navigation_server.nmea2000_datamodel import *
from navigation_server.generated.nmea2000_pb2 import nmea2000_decoded_pb

from navigation_server.generated.nmea2000_classes_gen_pb2 import *


class Pgn65359Mfg1851Class(NMEA2000DecodedMsg):

    _pgn = 65359
    _name = 'Raymarine: Pilot heading'
    _proprietary = True
    _manufacturer_id = 1851

    @staticmethod
    def protobuf_class():
        return Pgn65359Mfg1851ClassPb

    _struct_str_0 = struct.Struct('<HBHH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_true_heading', '_magnetic_heading')

    _static_size = 7

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        FloatFormatter('_true_heading', 'True Heading', '{:.4f}'),
        FloatFormatter('_magnetic_heading', 'Magnetic Heading', '{:.4f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def manufacturer_id(self) -> int:
        return self._manufacturer_id

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def true_heading(self) -> float:
        return self._true_heading

    @property
    def magnetic_heading(self) -> float:
        return self._magnetic_heading

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[1]
        self._true_heading = check_convert_float(val[2], 0xffff, 0.0001)
        self._magnetic_heading = check_convert_float(val[3], 0xffff, 0.0001)
        start_byte += 7
        return self

    #  Read Only no encode_payload
    def from_protobuf(self, message: Pgn65359Mfg1851ClassPb):
        self._sequence_id = message.sequence_id
        self._true_heading = message.true_heading
        self._magnetic_heading = message.magnetic_heading

    def as_protobuf(self) -> Pgn65359Mfg1851ClassPb:
        message = Pgn65359Mfg1851ClassPb()
        message.sequence_id = self._sequence_id
        message.true_heading = self._true_heading
        message.magnetic_heading = self._magnetic_heading
        return message

    def set_protobuf(self, message: Pgn65359Mfg1851ClassPb):
        message.sequence_id = self._sequence_id
        message.true_heading = self._true_heading
        message.magnetic_heading = self._magnetic_heading

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn65359Mfg1851ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, true_heading={self._true_heading}, magnetic_heading={self._magnetic_heading}]'


class Pgn65379Mfg1851Class(NMEA2000DecodedMsg):

    _pgn = 65379
    _name = 'Raymarine: Pilot mode'
    _proprietary = True
    _manufacturer_id = 1851

    @staticmethod
    def protobuf_class():
        return Pgn65379Mfg1851ClassPb

    _struct_str_0 = struct.Struct('<HBBBB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_pilot_mode', '_sub_mode', '_pilot_mode_data')

    _static_size = 6

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        GenericFormatter('_pilot_mode', 'Pilot Mode', 0xff),
        GenericFormatter('_sub_mode', 'Sub Mode', 0xff),
        GenericFormatter('_pilot_mode_data', 'Pilot Mode Data', 0xff)
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def manufacturer_id(self) -> int:
        return self._manufacturer_id

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def pilot_mode(self) -> int:
        return self._pilot_mode

    @property
    def sub_mode(self) -> int:
        return self._sub_mode

    @property
    def pilot_mode_data(self) -> int:
        return self._pilot_mode_data

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @pilot_mode.setter
    def pilot_mode(self, value: int):
        self._pilot_mode = value

    @sub_mode.setter
    def sub_mode(self, value: int):
        self._sub_mode = value

    @pilot_mode_data.setter
    def pilot_mode_data(self, value: int):
        self._pilot_mode_data = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[1]
        self._pilot_mode = val[2]
        self._sub_mode = val[3]
        self._pilot_mode_data = val[4]
        start_byte += 6
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = 0x7ff << 0
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._sequence_id, self._pilot_mode, self._sub_mode, self._pilot_mode_data)
        return buffer

    def from_protobuf(self, message: Pgn65379Mfg1851ClassPb):
        self._sequence_id = message.sequence_id
        self._pilot_mode = message.pilot_mode
        self._sub_mode = message.sub_mode
        self._pilot_mode_data = message.pilot_mode_data

    def as_protobuf(self) -> Pgn65379Mfg1851ClassPb:
        message = Pgn65379Mfg1851ClassPb()
        message.sequence_id = self._sequence_id
        message.pilot_mode = self._pilot_mode
        message.sub_mode = self._sub_mode
        message.pilot_mode_data = self._pilot_mode_data
        return message

    def set_protobuf(self, message: Pgn65379Mfg1851ClassPb):
        message.sequence_id = self._sequence_id
        message.pilot_mode = self._pilot_mode
        message.sub_mode = self._sub_mode
        message.pilot_mode_data = self._pilot_mode_data

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn65379Mfg1851ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, pilot_mode={self._pilot_mode}, sub_mode={self._sub_mode}, pilot_mode_data={self._pilot_mode_data}]'


class Pgn126992Class(NMEA2000DecodedMsg):

    _pgn = 126992
    _name = 'System Time'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn126992ClassPb

    _struct_str_0 = struct.Struct('<BBHI')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_source', '_date', '_time')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _source_enum = {
        0: 'GPS',
        1: 'GLONASS',
        2: 'Radio Station',
        3: 'Local Cesium clock',
        4: 'Local Rubidium clock',
        5: 'Local Crystal clock'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        EnumFormatter('_source', 'Source', 0xf, local = _source_enum ),
        GenericFormatter('_date', 'Date', 0xffff),
        FloatFormatter('_time', 'Time', '{:.2f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def source(self) -> int:
        return self._source

    @property
    def date(self) -> int:
        return self._date

    @property
    def time(self) -> float:
        return self._time

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @source.setter
    def source(self, value: int):
        self._source = value

    @date.setter
    def date(self, value: int):
        self._date = value

    @time.setter
    def time(self, value: float):
        self._time = value

    @property
    def source_text(self) -> str:
        return self._source_enum.get(self._source, 'source key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._source = (val[1] >> 4) & 0xF
        self._date = val[2]
        self._time = check_convert_float(val[3], 0xffffffff, 0.0001)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = 0xf << 0
        v0 |= (self._source & 0xf) << 4
        v1 = convert_to_int(self._time, 0xffffffff, 0.0001)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, self._date, v1)
        return buffer

    def from_protobuf(self, message: Pgn126992ClassPb):
        self._sequence_id = message.sequence_id
        self._source = message.source
        self._date = message.date
        self._time = message.time

    def as_protobuf(self) -> Pgn126992ClassPb:
        message = Pgn126992ClassPb()
        message.sequence_id = self._sequence_id
        message.source = self._source
        message.date = self._date
        message.time = self._time
        return message

    def set_protobuf(self, message: Pgn126992ClassPb):
        message.sequence_id = self._sequence_id
        message.source = self._source
        message.date = self._date
        message.time = self._time

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn126992ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, source={self._source}, date={self._date}, time={self._time}]'


class Pgn127245Class(NMEA2000DecodedMsg):

    _pgn = 127245
    _name = 'Rudder'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn127245ClassPb

    _struct_str_0 = struct.Struct('<BBhhH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_instance', '_direction', '_angle', '_position')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _direction_enum = {
        0: 'No direction order',
        1: 'Move to starboard',
        2: 'Move to port',
        7: 'Unavailable'
        }
    _json_format = (
        GenericFormatter('_instance', 'Instance', 0xff),
        EnumFormatter('_direction', 'Direction Order', 0x7, local = _direction_enum ),
        FloatFormatter('_angle', 'Angle Order', '{:.4f}'),
        FloatFormatter('_position', 'Position', '{:.4f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def instance(self) -> int:
        return self._instance

    @property
    def direction(self) -> int:
        return self._direction

    @property
    def angle(self) -> float:
        return self._angle

    @property
    def position(self) -> float:
        return self._position

    @instance.setter
    def instance(self, value: int):
        self._instance = value

    @direction.setter
    def direction(self, value: int):
        self._direction = value

    @angle.setter
    def angle(self, value: float):
        self._angle = value

    @position.setter
    def position(self, value: float):
        self._position = value

    @property
    def direction_text(self) -> str:
        return self._direction_enum.get(self._direction, 'direction key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._instance = val[0]
        self._direction = (val[1] >> 5) & 0x7
        self._angle = check_convert_float(val[2], 0x7fff, 0.0001)
        self._position = check_convert_float(val[3], 0x7fff, 0.0001)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = 0x1f << 0
        v0 |= (self._direction & 0x7) << 5
        v1 = convert_to_int(self._angle, 0x7fff, 0.0001)
        v2 = convert_to_int(self._position, 0x7fff, 0.0001)
        v3 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._instance, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn127245ClassPb):
        self._instance = message.instance
        self._direction = message.direction
        self._angle = message.angle
        self._position = message.position

    def as_protobuf(self) -> Pgn127245ClassPb:
        message = Pgn127245ClassPb()
        message.instance = self._instance
        message.direction = self._direction
        message.angle = self._angle
        message.position = self._position
        return message

    def set_protobuf(self, message: Pgn127245ClassPb):
        message.instance = self._instance
        message.direction = self._direction
        message.angle = self._angle
        message.position = self._position

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127245ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [instance={self._instance}, direction={self._direction}, angle={self._angle}, position={self._position}]'


class Pgn127250Class(NMEA2000DecodedMsg):

    _pgn = 127250
    _name = 'Vessel Heading'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn127250ClassPb

    _struct_str_0 = struct.Struct('<BHhhB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_heading', '_deviation', '_variation', '_reference')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _reference_enum = {
        0: 'True',
        1: 'Magnetic',
        2: 'Error'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        FloatFormatter('_heading', 'Heading', '{:.4f}'),
        FloatFormatter('_deviation', 'Deviation', '{:.4f}'),
        FloatFormatter('_variation', 'Variation', '{:.4f}'),
        EnumFormatter('_reference', 'Reference', 0x3, local = _reference_enum )
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def heading(self) -> float:
        return self._heading

    @property
    def deviation(self) -> float:
        return self._deviation

    @property
    def variation(self) -> float:
        return self._variation

    @property
    def reference(self) -> int:
        return self._reference

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @heading.setter
    def heading(self, value: float):
        self._heading = value

    @deviation.setter
    def deviation(self, value: float):
        self._deviation = value

    @variation.setter
    def variation(self, value: float):
        self._variation = value

    @reference.setter
    def reference(self, value: int):
        self._reference = value

    @property
    def reference_text(self) -> str:
        return self._reference_enum.get(self._reference, 'reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._heading = check_convert_float(val[1], 0xffff, 0.0001)
        self._deviation = check_convert_float(val[2], 0x7fff, 0.0001)
        self._variation = check_convert_float(val[3], 0x7fff, 0.0001)
        self._reference = val[4] & 0x3
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._heading, 0xffff, 0.0001)
        v1 = convert_to_int(self._deviation, 0x7fff, 0.0001)
        v2 = convert_to_int(self._variation, 0x7fff, 0.0001)
        v3 = (self._reference & 0x3) << 0
        v3 |= 0x3f << 2
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn127250ClassPb):
        self._sequence_id = message.sequence_id
        self._heading = message.heading
        self._deviation = message.deviation
        self._variation = message.variation
        self._reference = message.reference

    def as_protobuf(self) -> Pgn127250ClassPb:
        message = Pgn127250ClassPb()
        message.sequence_id = self._sequence_id
        message.heading = self._heading
        message.deviation = self._deviation
        message.variation = self._variation
        message.reference = self._reference
        return message

    def set_protobuf(self, message: Pgn127250ClassPb):
        message.sequence_id = self._sequence_id
        message.heading = self._heading
        message.deviation = self._deviation
        message.variation = self._variation
        message.reference = self._reference

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127250ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, heading={self._heading}, deviation={self._deviation}, variation={self._variation}, reference={self._reference}]'


class Pgn127258Class(NMEA2000DecodedMsg):

    _pgn = 127258
    _name = 'Magnetic Variation'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn127258ClassPb

    _struct_str_0 = struct.Struct('<BBHh')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_source', '_age_of_service', '_variation')

    _static_size = 6

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _source_enum = {
        0: 'Manual',
        1: 'Automatic Chart',
        2: 'Automatic Table',
        3: 'Automatic Calculation',
        4: 'WMM 2000',
        5: 'WMM 2005',
        6: 'WMM 2010',
        7: 'WMM 2015',
        8: 'WMM 2020'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        EnumFormatter('_source', 'Source', 0xf, local = _source_enum ),
        GenericFormatter('_age_of_service', 'Age of service', 0xffff),
        FloatFormatter('_variation', 'Variation', '{:.4f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def source(self) -> int:
        return self._source

    @property
    def age_of_service(self) -> int:
        return self._age_of_service

    @property
    def variation(self) -> float:
        return self._variation

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @source.setter
    def source(self, value: int):
        self._source = value

    @age_of_service.setter
    def age_of_service(self, value: int):
        self._age_of_service = value

    @variation.setter
    def variation(self, value: float):
        self._variation = value

    @property
    def source_text(self) -> str:
        return self._source_enum.get(self._source, 'source key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._source = val[1] & 0xF
        self._age_of_service = val[2]
        self._variation = check_convert_float(val[3], 0x7fff, 0.0001)
        start_byte += 6
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._source & 0xf) << 0
        v0 |= 0xf << 4
        v1 = convert_to_int(self._variation, 0x7fff, 0.0001)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, self._age_of_service, v1)
        return buffer

    def from_protobuf(self, message: Pgn127258ClassPb):
        self._sequence_id = message.sequence_id
        self._source = message.source
        self._age_of_service = message.age_of_service
        self._variation = message.variation

    def as_protobuf(self) -> Pgn127258ClassPb:
        message = Pgn127258ClassPb()
        message.sequence_id = self._sequence_id
        message.source = self._source
        message.age_of_service = self._age_of_service
        message.variation = self._variation
        return message

    def set_protobuf(self, message: Pgn127258ClassPb):
        message.sequence_id = self._sequence_id
        message.source = self._source
        message.age_of_service = self._age_of_service
        message.variation = self._variation

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127258ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, source={self._source}, age_of_service={self._age_of_service}, variation={self._variation}]'


class Pgn127488Class(NMEA2000DecodedMsg):

    _pgn = 127488
    _name = 'Engine Parameters, Rapid Update'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn127488ClassPb

    _struct_str_0 = struct.Struct('<BHHbH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_engine_instance', '_engine_speed')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_engine_instance', 'Engine Instance', 0xff),
        FloatFormatter('_engine_speed', 'Engine Speed', '{:.0f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def engine_instance(self) -> int:
        return self._engine_instance

    @property
    def engine_speed(self) -> float:
        return self._engine_speed

    @engine_instance.setter
    def engine_instance(self, value: int):
        self._engine_instance = value

    @engine_speed.setter
    def engine_speed(self, value: float):
        self._engine_speed = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._engine_instance = val[0]
        self._engine_speed = check_convert_float(val[1], 0xffff, 0.25)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._engine_speed, 0xffff, 0.25)
        v1 = 0xffff
        v2 = 0x7f
        v3 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._engine_instance, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn127488ClassPb):
        self._engine_instance = message.engine_instance
        self._engine_speed = message.engine_speed

    def as_protobuf(self) -> Pgn127488ClassPb:
        message = Pgn127488ClassPb()
        message.engine_instance = self._engine_instance
        message.engine_speed = self._engine_speed
        return message

    def set_protobuf(self, message: Pgn127488ClassPb):
        message.engine_instance = self._engine_instance
        message.engine_speed = self._engine_speed

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127488ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [engine_instance={self._engine_instance}, engine_speed={self._engine_speed}]'


class Pgn127489Class(NMEA2000DecodedMsg):

    _pgn = 127489
    _name = 'Engine Parameters, Dynamic'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn127489ClassPb

    _struct_str_0 = struct.Struct('<BHHHhhIHHBhhbb')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_engine_instance', '_oil_pressure', '_oil_temperature', '_temperature', '_alternator_voltage', '_fuel_rate', '_total_engine_hours')

    _static_size = 26

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_engine_instance', 'Engine Instance', 0xff),
        FloatFormatter('_oil_pressure', 'Oil pressure', '{:.0f}'),
        FloatFormatter('_oil_temperature', 'Oil temperature', '{:.1f}'),
        FloatFormatter('_temperature', 'Temperature', '{:.1f}'),
        FloatFormatter('_alternator_voltage', 'Alternator Potential', '{:.2f}'),
        FloatFormatter('_fuel_rate', 'Fuel Rate', '{:.2f}'),
        FloatFormatter('_total_engine_hours', 'Total Engine hours', '{:.2f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def engine_instance(self) -> int:
        return self._engine_instance

    @property
    def oil_pressure(self) -> float:
        return self._oil_pressure

    @property
    def oil_temperature(self) -> float:
        return self._oil_temperature

    @property
    def temperature(self) -> float:
        return self._temperature

    @property
    def alternator_voltage(self) -> float:
        return self._alternator_voltage

    @property
    def fuel_rate(self) -> float:
        return self._fuel_rate

    @property
    def total_engine_hours(self) -> float:
        return self._total_engine_hours

    @engine_instance.setter
    def engine_instance(self, value: int):
        self._engine_instance = value

    @oil_pressure.setter
    def oil_pressure(self, value: float):
        self._oil_pressure = value

    @oil_temperature.setter
    def oil_temperature(self, value: float):
        self._oil_temperature = value

    @temperature.setter
    def temperature(self, value: float):
        self._temperature = value

    @alternator_voltage.setter
    def alternator_voltage(self, value: float):
        self._alternator_voltage = value

    @fuel_rate.setter
    def fuel_rate(self, value: float):
        self._fuel_rate = value

    @total_engine_hours.setter
    def total_engine_hours(self, value: float):
        self._total_engine_hours = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._engine_instance = val[0]
        self._oil_pressure = check_convert_float(val[1], 0xffff, 100.0)
        self._oil_temperature = check_convert_float(val[2], 0xffff, 0.1)
        self._temperature = check_convert_float(val[3], 0xffff, 0.01)
        self._alternator_voltage = check_convert_float(val[4], 0x7fff, 0.01)
        self._fuel_rate = check_convert_float(val[5], 0x7fff, 0.1)
        self._total_engine_hours = float(val[6])
        start_byte += 26
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._oil_pressure, 0xffff, 100.0)
        v1 = convert_to_int(self._oil_temperature, 0xffff, 0.1)
        v2 = convert_to_int(self._temperature, 0xffff, 0.01)
        v3 = convert_to_int(self._alternator_voltage, 0x7fff, 0.01)
        v4 = convert_to_int(self._fuel_rate, 0x7fff, 0.1)
        v5 = convert_to_int(self._total_engine_hours, 0xffffffff, None)
        v6 = 0xffff
        v7 = 0xffff
        v8 = 0xff
        v9 = 0x7fff
        v10 = 0x7fff
        v11 = 0x7f
        v12 = 0x7f
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._engine_instance, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
        return buffer

    def from_protobuf(self, message: Pgn127489ClassPb):
        self._engine_instance = message.engine_instance
        self._oil_pressure = message.oil_pressure
        self._oil_temperature = message.oil_temperature
        self._temperature = message.temperature
        self._alternator_voltage = message.alternator_voltage
        self._fuel_rate = message.fuel_rate
        self._total_engine_hours = message.total_engine_hours

    def as_protobuf(self) -> Pgn127489ClassPb:
        message = Pgn127489ClassPb()
        message.engine_instance = self._engine_instance
        message.oil_pressure = self._oil_pressure
        message.oil_temperature = self._oil_temperature
        message.temperature = self._temperature
        message.alternator_voltage = self._alternator_voltage
        message.fuel_rate = self._fuel_rate
        message.total_engine_hours = self._total_engine_hours
        return message

    def set_protobuf(self, message: Pgn127489ClassPb):
        message.engine_instance = self._engine_instance
        message.oil_pressure = self._oil_pressure
        message.oil_temperature = self._oil_temperature
        message.temperature = self._temperature
        message.alternator_voltage = self._alternator_voltage
        message.fuel_rate = self._fuel_rate
        message.total_engine_hours = self._total_engine_hours

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127489ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [engine_instance={self._engine_instance}, oil_pressure={self._oil_pressure}, oil_temperature={self._oil_temperature}, temperature={self._temperature}, alternator_voltage={self._alternator_voltage}, fuel_rate={self._fuel_rate}, total_engine_hours={self._total_engine_hours}]'


class Pgn127507Class(NMEA2000DecodedMsg):

    _pgn = 127507
    _name = 'Charger Status'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn127507ClassPb

    _struct_str_0 = struct.Struct('<BBBBBH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_charger_instance', '_battery_instance', '_operating_state', '_charger_mode', '_charger_enable', '_equalization_pending', '_eq_time_remaining')

    _static_size = 7

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_charger_instance', 'Charger Instance', 0xff),
        GenericFormatter('_battery_instance', 'Battery Instance', 0xff),
        GenericFormatter('_operating_state', 'Operating State', 0xff),
        GenericFormatter('_charger_mode', 'Charge Mode', 0xff),
        GenericFormatter('_charger_enable', 'Charger Enable/Disable', 0x3),
        GenericFormatter('_equalization_pending', 'Equalization Pending', 0x3),
        GenericFormatter('_eq_time_remaining', 'Equalization Time Remaining', 0xffff)
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def charger_instance(self) -> int:
        return self._charger_instance

    @property
    def battery_instance(self) -> int:
        return self._battery_instance

    @property
    def operating_state(self) -> int:
        return self._operating_state

    @property
    def charger_mode(self) -> int:
        return self._charger_mode

    @property
    def charger_enable(self) -> int:
        return self._charger_enable

    @property
    def equalization_pending(self) -> int:
        return self._equalization_pending

    @property
    def eq_time_remaining(self) -> int:
        return self._eq_time_remaining

    @charger_instance.setter
    def charger_instance(self, value: int):
        self._charger_instance = value

    @battery_instance.setter
    def battery_instance(self, value: int):
        self._battery_instance = value

    @operating_state.setter
    def operating_state(self, value: int):
        self._operating_state = value

    @charger_mode.setter
    def charger_mode(self, value: int):
        self._charger_mode = value

    @charger_enable.setter
    def charger_enable(self, value: int):
        self._charger_enable = value

    @equalization_pending.setter
    def equalization_pending(self, value: int):
        self._equalization_pending = value

    @eq_time_remaining.setter
    def eq_time_remaining(self, value: int):
        self._eq_time_remaining = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._charger_instance = val[0]
        self._battery_instance = val[1]
        self._operating_state = val[2]
        self._charger_mode = val[3]
        self._charger_enable = val[4] & 0x3
        self._equalization_pending = (val[4] >> 2) & 0x3
        self._eq_time_remaining = val[5]
        start_byte += 7
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._charger_enable & 0x3) << 0
        v0 |= (self._equalization_pending & 0x3) << 2
        v0 |= 0xf << 4
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._charger_instance, self._battery_instance, self._operating_state, self._charger_mode, v0, self._eq_time_remaining)
        return buffer

    def from_protobuf(self, message: Pgn127507ClassPb):
        self._charger_instance = message.charger_instance
        self._battery_instance = message.battery_instance
        self._operating_state = message.operating_state
        self._charger_mode = message.charger_mode
        self._charger_enable = message.charger_enable
        self._equalization_pending = message.equalization_pending
        self._eq_time_remaining = message.eq_time_remaining

    def as_protobuf(self) -> Pgn127507ClassPb:
        message = Pgn127507ClassPb()
        message.charger_instance = self._charger_instance
        message.battery_instance = self._battery_instance
        message.operating_state = self._operating_state
        message.charger_mode = self._charger_mode
        message.charger_enable = self._charger_enable
        message.equalization_pending = self._equalization_pending
        message.eq_time_remaining = self._eq_time_remaining
        return message

    def set_protobuf(self, message: Pgn127507ClassPb):
        message.charger_instance = self._charger_instance
        message.battery_instance = self._battery_instance
        message.operating_state = self._operating_state
        message.charger_mode = self._charger_mode
        message.charger_enable = self._charger_enable
        message.equalization_pending = self._equalization_pending
        message.eq_time_remaining = self._eq_time_remaining

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127507ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [charger_instance={self._charger_instance}, battery_instance={self._battery_instance}, operating_state={self._operating_state}, charger_mode={self._charger_mode}, charger_enable={self._charger_enable}, equalization_pending={self._equalization_pending}, eq_time_remaining={self._eq_time_remaining}]'


class Pgn127508Class(NMEA2000DecodedMsg):

    _pgn = 127508
    _name = 'Battery Status'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn127508ClassPb

    _struct_str_0 = struct.Struct('<BhhHB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_battery_instance', '_voltage', '_current', '_temperature', '_sequence_id')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_battery_instance', 'Battery Instance', 0xff),
        FloatFormatter('_voltage', 'Voltage', '{:.2f}'),
        FloatFormatter('_current', 'Current', '{:.2f}'),
        FloatFormatter('_temperature', 'Temperature', '{:.1f}'),
        GenericFormatter('_sequence_id', 'SID', 0xff)
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def battery_instance(self) -> int:
        return self._battery_instance

    @property
    def voltage(self) -> float:
        return self._voltage

    @property
    def current(self) -> float:
        return self._current

    @property
    def temperature(self) -> float:
        return self._temperature

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @battery_instance.setter
    def battery_instance(self, value: int):
        self._battery_instance = value

    @voltage.setter
    def voltage(self, value: float):
        self._voltage = value

    @current.setter
    def current(self, value: float):
        self._current = value

    @temperature.setter
    def temperature(self, value: float):
        self._temperature = value

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._battery_instance = val[0]
        self._voltage = check_convert_float(val[1], 0x7fff, 0.01)
        self._current = check_convert_float(val[2], 0x7fff, 0.1)
        self._temperature = check_convert_float(val[3], 0xffff, 0.01)
        self._sequence_id = val[4]
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._voltage, 0x7fff, 0.01)
        v1 = convert_to_int(self._current, 0x7fff, 0.1)
        v2 = convert_to_int(self._temperature, 0xffff, 0.01)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._battery_instance, v0, v1, v2, self._sequence_id)
        return buffer

    def from_protobuf(self, message: Pgn127508ClassPb):
        self._battery_instance = message.battery_instance
        self._voltage = message.voltage
        self._current = message.current
        self._temperature = message.temperature
        self._sequence_id = message.sequence_id

    def as_protobuf(self) -> Pgn127508ClassPb:
        message = Pgn127508ClassPb()
        message.battery_instance = self._battery_instance
        message.voltage = self._voltage
        message.current = self._current
        message.temperature = self._temperature
        message.sequence_id = self._sequence_id
        return message

    def set_protobuf(self, message: Pgn127508ClassPb):
        message.battery_instance = self._battery_instance
        message.voltage = self._voltage
        message.current = self._current
        message.temperature = self._temperature
        message.sequence_id = self._sequence_id

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127508ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [battery_instance={self._battery_instance}, voltage={self._voltage}, current={self._current}, temperature={self._temperature}, sequence_id={self._sequence_id}]'


class Pgn127751Class(NMEA2000DecodedMsg):

    _pgn = 127751
    _name = 'DC Voltage/Current'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn127751ClassPb

    _struct_str_0 = struct.Struct('<BBHhbB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_connection_number', '_voltage', '_current')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        GenericFormatter('_connection_number', 'Connection number', 0xff),
        FloatFormatter('_voltage', 'DC voltage', '{:.2f}'),
        FloatFormatter('_current', 'DC Current', '{:.2f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def connection_number(self) -> int:
        return self._connection_number

    @property
    def voltage(self) -> float:
        return self._voltage

    @property
    def current(self) -> float:
        return self._current

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @connection_number.setter
    def connection_number(self, value: int):
        self._connection_number = value

    @voltage.setter
    def voltage(self, value: float):
        self._voltage = value

    @current.setter
    def current(self, value: float):
        self._current = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._connection_number = val[1]
        self._voltage = check_convert_float(val[2], 0xffff, 0.1)
        word = val[3] + (val[4] << 16)
        self._current = check_convert_float(word, 0x7fffff, 0.01)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._voltage, 0xffff, 0.1)
        word = convert_to_int(self._current, 0x7fffff, 0.01)
        v1 = word & 0xffff
        v2 = (word >> 16) & 0xff
        v3 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, self._connection_number, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn127751ClassPb):
        self._sequence_id = message.sequence_id
        self._connection_number = message.connection_number
        self._voltage = message.voltage
        self._current = message.current

    def as_protobuf(self) -> Pgn127751ClassPb:
        message = Pgn127751ClassPb()
        message.sequence_id = self._sequence_id
        message.connection_number = self._connection_number
        message.voltage = self._voltage
        message.current = self._current
        return message

    def set_protobuf(self, message: Pgn127751ClassPb):
        message.sequence_id = self._sequence_id
        message.connection_number = self._connection_number
        message.voltage = self._voltage
        message.current = self._current

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127751ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, connection_number={self._connection_number}, voltage={self._voltage}, current={self._current}]'


class Pgn128259Class(NMEA2000DecodedMsg):

    _pgn = 128259
    _name = 'Speed'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn128259ClassPb

    _struct_str_0 = struct.Struct('<BhhBH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_speed_through_water', '_speed_over_ground', '_speed_through_water_reference')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _speed_through_water_reference_enum = {
        0: 'Paddle wheel',
        1: 'Pitot tube',
        2: 'Doppler log',
        3: 'Correlation log (Ultra-Sound)',
        4: 'EM log (Electro-Magnetic)'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        FloatFormatter('_speed_through_water', 'Speed Water Referenced', '{:.2f}'),
        FloatFormatter('_speed_over_ground', 'Speed Ground Referenced', '{:.2f}'),
        EnumFormatter('_speed_through_water_reference', 'Speed Water Referenced Type', 0xff, local = _speed_through_water_reference_enum )
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def speed_through_water(self) -> float:
        return self._speed_through_water

    @property
    def speed_over_ground(self) -> float:
        return self._speed_over_ground

    @property
    def speed_through_water_reference(self) -> int:
        return self._speed_through_water_reference

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @speed_through_water.setter
    def speed_through_water(self, value: float):
        self._speed_through_water = value

    @speed_over_ground.setter
    def speed_over_ground(self, value: float):
        self._speed_over_ground = value

    @speed_through_water_reference.setter
    def speed_through_water_reference(self, value: int):
        self._speed_through_water_reference = value

    @property
    def speed_through_water_reference_text(self) -> str:
        return self._speed_through_water_reference_enum.get(self._speed_through_water_reference, 'speed_through_water_reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._speed_through_water = check_convert_float(val[1], 0x7fff, 0.01)
        self._speed_over_ground = check_convert_float(val[2], 0x7fff, 0.01)
        self._speed_through_water_reference = val[3]
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._speed_through_water, 0x7fff, 0.01)
        v1 = convert_to_int(self._speed_over_ground, 0x7fff, 0.01)
        v2 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, self._speed_through_water_reference, v2)
        return buffer

    def from_protobuf(self, message: Pgn128259ClassPb):
        self._sequence_id = message.sequence_id
        self._speed_through_water = message.speed_through_water
        self._speed_over_ground = message.speed_over_ground
        self._speed_through_water_reference = message.speed_through_water_reference

    def as_protobuf(self) -> Pgn128259ClassPb:
        message = Pgn128259ClassPb()
        message.sequence_id = self._sequence_id
        message.speed_through_water = self._speed_through_water
        message.speed_over_ground = self._speed_over_ground
        message.speed_through_water_reference = self._speed_through_water_reference
        return message

    def set_protobuf(self, message: Pgn128259ClassPb):
        message.sequence_id = self._sequence_id
        message.speed_through_water = self._speed_through_water
        message.speed_over_ground = self._speed_over_ground
        message.speed_through_water_reference = self._speed_through_water_reference

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn128259ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, speed_through_water={self._speed_through_water}, speed_over_ground={self._speed_over_ground}, speed_through_water_reference={self._speed_through_water_reference}]'


class Pgn128267Class(NMEA2000DecodedMsg):

    _pgn = 128267
    _name = 'Water Depth'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn128267ClassPb

    _struct_str_0 = struct.Struct('<BIhB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_depth', '_offset', '_range')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        FloatFormatter('_depth', 'Depth', '{:.1f}'),
        FloatFormatter('_offset', 'Offset', '{:.1f}'),
        FloatFormatter('_range', 'Range', '{:.1f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def depth(self) -> float:
        return self._depth

    @property
    def offset(self) -> float:
        return self._offset

    @property
    def range(self) -> float:
        return self._range

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @depth.setter
    def depth(self, value: float):
        self._depth = value

    @offset.setter
    def offset(self, value: float):
        self._offset = value

    @range.setter
    def range(self, value: float):
        self._range = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._depth = check_convert_float(val[1], 0xffffffff, 0.01)
        self._offset = check_convert_float(val[2], 0x7fff, 0.001)
        self._range = check_convert_float(val[3], 0xff, 10.0)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._depth, 0xffffffff, 0.01)
        v1 = convert_to_int(self._offset, 0x7fff, 0.001)
        v2 = convert_to_int(self._range, 0xff, 10.0)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, v2)
        return buffer

    def from_protobuf(self, message: Pgn128267ClassPb):
        self._sequence_id = message.sequence_id
        self._depth = message.depth
        self._offset = message.offset
        self._range = message.range

    def as_protobuf(self) -> Pgn128267ClassPb:
        message = Pgn128267ClassPb()
        message.sequence_id = self._sequence_id
        message.depth = self._depth
        message.offset = self._offset
        message.range = self._range
        return message

    def set_protobuf(self, message: Pgn128267ClassPb):
        message.sequence_id = self._sequence_id
        message.depth = self._depth
        message.offset = self._offset
        message.range = self._range

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn128267ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, depth={self._depth}, offset={self._offset}, range={self._range}]'


class Pgn128275Class(NMEA2000DecodedMsg):

    _pgn = 128275
    _name = 'Distance Log'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn128275ClassPb

    _struct_str_0 = struct.Struct('<HIII')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_date', '_time', '_total_log', '_trip_log')

    _static_size = 14

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_date', 'Date', 0xffff),
        FloatFormatter('_time', 'Time', '{:.2f}'),
        GenericFormatter('_total_log', 'Log', 0xffffffff),
        GenericFormatter('_trip_log', 'Trip Log', 0xffffffff)
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def date(self) -> int:
        return self._date

    @property
    def time(self) -> float:
        return self._time

    @property
    def total_log(self) -> int:
        return self._total_log

    @property
    def trip_log(self) -> int:
        return self._trip_log

    @date.setter
    def date(self, value: int):
        self._date = value

    @time.setter
    def time(self, value: float):
        self._time = value

    @total_log.setter
    def total_log(self, value: int):
        self._total_log = value

    @trip_log.setter
    def trip_log(self, value: int):
        self._trip_log = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._date = val[0]
        self._time = check_convert_float(val[1], 0xffffffff, 0.0001)
        self._total_log = val[2]
        self._trip_log = val[3]
        start_byte += 14
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._time, 0xffffffff, 0.0001)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._date, v0, self._total_log, self._trip_log)
        return buffer

    def from_protobuf(self, message: Pgn128275ClassPb):
        self._date = message.date
        self._time = message.time
        self._total_log = message.total_log
        self._trip_log = message.trip_log

    def as_protobuf(self) -> Pgn128275ClassPb:
        message = Pgn128275ClassPb()
        message.date = self._date
        message.time = self._time
        message.total_log = self._total_log
        message.trip_log = self._trip_log
        return message

    def set_protobuf(self, message: Pgn128275ClassPb):
        message.date = self._date
        message.time = self._time
        message.total_log = self._total_log
        message.trip_log = self._trip_log

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn128275ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [date={self._date}, time={self._time}, total_log={self._total_log}, trip_log={self._trip_log}]'


class Pgn129025Class(NMEA2000DecodedMsg):

    _pgn = 129025
    _name = 'Position, Rapid Update'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129025ClassPb

    _struct_str_0 = struct.Struct('<ii')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_latitude', '_longitude')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        FloatFormatter('_latitude', 'Latitude', '{:.6f}'),
        FloatFormatter('_longitude', 'Longitude', '{:.6f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def longitude(self) -> float:
        return self._longitude

    @latitude.setter
    def latitude(self, value: float):
        self._latitude = value

    @longitude.setter
    def longitude(self, value: float):
        self._longitude = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._latitude = check_convert_float(val[0], 0x7fffffff, 1e-07)
        self._longitude = check_convert_float(val[1], 0x7fffffff, 1e-07)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._latitude, 0x7fffffff, 1e-07)
        v1 = convert_to_int(self._longitude, 0x7fffffff, 1e-07)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn129025ClassPb):
        self._latitude = message.latitude
        self._longitude = message.longitude

    def as_protobuf(self) -> Pgn129025ClassPb:
        message = Pgn129025ClassPb()
        message.latitude = self._latitude
        message.longitude = self._longitude
        return message

    def set_protobuf(self, message: Pgn129025ClassPb):
        message.latitude = self._latitude
        message.longitude = self._longitude

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129025ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [latitude={self._latitude}, longitude={self._longitude}]'


class Pgn129026Class(NMEA2000DecodedMsg):

    _pgn = 129026
    _name = 'COG & SOG, Rapid Update'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129026ClassPb

    _struct_str_0 = struct.Struct('<BBHHH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_COG_reference', '_COG', '_SOG')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _COG_reference_enum = {
        0: 'True',
        1: 'Magnetic',
        2: 'Error'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        EnumFormatter('_COG_reference', 'COG Reference', 0x3, local = _COG_reference_enum ),
        FloatFormatter('_COG', 'COG', '{:.4f}'),
        FloatFormatter('_SOG', 'SOG', '{:.2f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def COG_reference(self) -> int:
        return self._COG_reference

    @property
    def COG(self) -> float:
        return self._COG

    @property
    def SOG(self) -> float:
        return self._SOG

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @COG_reference.setter
    def COG_reference(self, value: int):
        self._COG_reference = value

    @COG.setter
    def COG(self, value: float):
        self._COG = value

    @SOG.setter
    def SOG(self, value: float):
        self._SOG = value

    @property
    def COG_reference_text(self) -> str:
        return self._COG_reference_enum.get(self._COG_reference, 'COG_reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        if self._sequence_id == 255:
            raise N2KInvalidMessageException
        self._COG_reference = val[1] & 0x3
        self._COG = check_convert_float(val[2], 0xffff, 0.0001)
        self._SOG = check_convert_float(val[3], 0xffff, 0.01)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._COG_reference & 0x3) << 0
        v0 |= 0x3f << 2
        v1 = convert_to_int(self._COG, 0xffff, 0.0001)
        v2 = convert_to_int(self._SOG, 0xffff, 0.01)
        v3 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn129026ClassPb):
        self._sequence_id = message.sequence_id
        self._COG_reference = message.COG_reference
        self._COG = message.COG
        self._SOG = message.SOG

    def as_protobuf(self) -> Pgn129026ClassPb:
        message = Pgn129026ClassPb()
        message.sequence_id = self._sequence_id
        message.COG_reference = self._COG_reference
        message.COG = self._COG
        message.SOG = self._SOG
        return message

    def set_protobuf(self, message: Pgn129026ClassPb):
        message.sequence_id = self._sequence_id
        message.COG_reference = self._COG_reference
        message.COG = self._COG
        message.SOG = self._SOG

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129026ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, COG_reference={self._COG_reference}, COG={self._COG}, SOG={self._SOG}]'


class Pgn129029Class(NMEA2000DecodedMsg):

    class Ref_StationsClass:

        _struct_str_0 = struct.Struct('<Hh')
        _struct_str_0_size = _struct_str_0.size
        __slots__ = ('_GNSS_type', '_station_id', '_age_DGNSS_correction')

        _static_size = 4

        @classmethod
        def size(cls):
            return cls._static_size

        @staticmethod
        def variable_size() -> bool:
            return False


        _GNSS_type_enum = 'GNSS type'

        _json_format = (
            EnumFormatter('_GNSS_type', 'Reference Station Type', 0xf, global_enum ='GNSS type' ),
            GenericFormatter('_station_id', 'Reference Station ID', 0xfff),
            FloatFormatter('_age_DGNSS_correction', 'Age of DGNSS Corrections', '{:.2f}')
            )

        def json_format(self):
            return self._json_format

        def __init__(self, protobuf=None):
            if protobuf is not None:
                self.from_protobuf(protobuf)

        @property
        def GNSS_type(self) -> int:
            return self._GNSS_type

        @property
        def station_id(self) -> int:
            return self._station_id

        @property
        def age_DGNSS_correction(self) -> float:
            return self._age_DGNSS_correction

        @GNSS_type.setter
        def GNSS_type(self, value: int):
            self._GNSS_type = value

        @station_id.setter
        def station_id(self, value: int):
            self._station_id = value

        @age_DGNSS_correction.setter
        def age_DGNSS_correction(self, value: float):
            self._age_DGNSS_correction = value

        @property
        def GNSS_type_text(self) -> str:
            return resolve_global_enum(self._GNSS_type_enum, self._GNSS_type)

        def decode_payload(self, payload, start_byte=0):
            val = self._struct_str_0.unpack_from(payload, start_byte)
            self._GNSS_type = val[0] & 0xF
            self._station_id = (val[0] >> 4) & 0xFFF
            self._age_DGNSS_correction = check_convert_float(val[1], 0x7fff, 0.01)
            start_byte += 4
            return self

        def encode_payload(self, buffer, start_byte):
            v0 = (self._GNSS_type & 0xf) << 0
            v0 |= (self._station_id & 0xfff) << 4
            v1 = convert_to_int(self._age_DGNSS_correction, 0x7fff, 0.01)
            self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, v1)
            return self._static_size + start_byte

        def from_protobuf(self, message: Pgn129029ClassPb.Ref_StationsClassPb):
            self._GNSS_type = message.GNSS_type
            self._station_id = message.station_id
            self._age_DGNSS_correction = message.age_DGNSS_correction

        def as_protobuf(self) -> Pgn129029ClassPb.Ref_StationsClassPb:
            message = Pgn129029ClassPb.Ref_StationsClassPb()
            message.GNSS_type = self._GNSS_type
            message.station_id = self._station_id
            message.age_DGNSS_correction = self._age_DGNSS_correction
            return message

        def set_protobuf(self, message: Pgn129029ClassPb.Ref_StationsClassPb):
            message.GNSS_type = self._GNSS_type
            message.station_id = self._station_id
            message.age_DGNSS_correction = self._age_DGNSS_correction

        def __str__(self):
            return f'(Ref_StationsClass) [GNSS_type={self._GNSS_type}, station_id={self._station_id}, age_DGNSS_correction={self._age_DGNSS_correction}]'


    _pgn = 129029
    _name = 'GNSS Position Data'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129029ClassPb

    _struct_str_0 = struct.Struct('<BHIqqqBBBhhiB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_date', '_time', '_latitude', '_longitude', '_altitude', '_GNSS_type', '_method', '_integrity', '_number_of_sv', '_HDOP', '_PDOP', '_geoidal_separation', '_nb_ref_stations', '_ref_stations')


    @staticmethod
    def variable_size() -> bool:
        return True

    _GNSS_type_enum = 'GNSS type'
    _method_enum = {
        0: 'no GNSS',
        1: 'GNSS fix',
        2: 'DGNSS fix',
        3: 'Precise GNSS',
        4: 'RTK Fixed Integer',
        5: 'RTK float',
        6: 'Estimated (DR) mode',
        7: 'Manual Input',
        8: 'Simulate mode'
        }
    _integrity_enum = {
        0: 'No integrity checking',
        1: 'Safe',
        2: 'Caution'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        GenericFormatter('_date', 'Date', 0xffff),
        FloatFormatter('_time', 'Time', '{:.2f}'),
        FloatFormatter('_latitude', 'Latitude', '{:.6f}'),
        FloatFormatter('_longitude', 'Longitude', '{:.6f}'),
        FloatFormatter('_altitude', 'Altitude', '{:.1f}'),
        EnumFormatter('_GNSS_type', 'GNSS type', 0xf, global_enum ='GNSS type' ),
        EnumFormatter('_method', 'Method', 0xf, local = _method_enum ),
        EnumFormatter('_integrity', 'Integrity', 0x3, local = _integrity_enum ),
        GenericFormatter('_number_of_sv', 'Number of SVs', 0xff),
        FloatFormatter('_HDOP', 'HDOP', '{:.0f}'),
        FloatFormatter('_PDOP', 'PDOP', '{:.0f}'),
        FloatFormatter('_geoidal_separation', 'Geoidal Separation', '{:.0f}'),
        RepeatedFormatter('_nb_ref_stations', 'nStations', '_ref_stations'),
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        self._nb_ref_stations = 0
        self._ref_stations = []
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def date(self) -> int:
        return self._date

    @property
    def time(self) -> float:
        return self._time

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def longitude(self) -> float:
        return self._longitude

    @property
    def altitude(self) -> float:
        return self._altitude

    @property
    def GNSS_type(self) -> int:
        return self._GNSS_type

    @property
    def method(self) -> int:
        return self._method

    @property
    def integrity(self) -> int:
        return self._integrity

    @property
    def number_of_sv(self) -> int:
        return self._number_of_sv

    @property
    def HDOP(self) -> float:
        return self._HDOP

    @property
    def PDOP(self) -> float:
        return self._PDOP

    @property
    def geoidal_separation(self) -> float:
        return self._geoidal_separation

    @property
    def nb_ref_stations(self) -> int:
        return self._nb_ref_stations

    @property
    def ref_stations(self) -> list:
        return self._ref_stations

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @date.setter
    def date(self, value: int):
        self._date = value

    @time.setter
    def time(self, value: float):
        self._time = value

    @latitude.setter
    def latitude(self, value: float):
        self._latitude = value

    @longitude.setter
    def longitude(self, value: float):
        self._longitude = value

    @altitude.setter
    def altitude(self, value: float):
        self._altitude = value

    @GNSS_type.setter
    def GNSS_type(self, value: int):
        self._GNSS_type = value

    @method.setter
    def method(self, value: int):
        self._method = value

    @integrity.setter
    def integrity(self, value: int):
        self._integrity = value

    @number_of_sv.setter
    def number_of_sv(self, value: int):
        self._number_of_sv = value

    @HDOP.setter
    def HDOP(self, value: float):
        self._HDOP = value

    @PDOP.setter
    def PDOP(self, value: float):
        self._PDOP = value

    @geoidal_separation.setter
    def geoidal_separation(self, value: float):
        self._geoidal_separation = value

    @nb_ref_stations.setter
    def nb_ref_stations(self, value: int):
        self._nb_ref_stations = value

    @property
    def GNSS_type_text(self) -> str:
        return resolve_global_enum(self._GNSS_type_enum, self._GNSS_type)

    @property
    def method_text(self) -> str:
        return self._method_enum.get(self._method, 'method key error')

    @property
    def integrity_text(self) -> str:
        return self._integrity_enum.get(self._integrity, 'integrity key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._date = val[1]
        self._time = check_convert_float(val[2], 0xffffffff, 0.0001)
        self._latitude = check_convert_float(val[3], 0x7fffffffffffffff, 1e-16)
        self._longitude = check_convert_float(val[4], 0x7fffffffffffffff, 1e-16)
        self._altitude = check_convert_float(val[5], 0x7fffffffffffffff, 1e-06)
        self._GNSS_type = val[6] & 0xF
        self._method = (val[6] >> 4) & 0xF
        self._integrity = val[7] & 0x3
        self._number_of_sv = val[8]
        self._HDOP = check_convert_float(val[9], 0x7fff, 0.01)
        self._PDOP = check_convert_float(val[10], 0x7fff, 0.01)
        self._geoidal_separation = check_convert_float(val[11], 0x7fffffff, 0.01)
        self._nb_ref_stations = check_valid(val[12], 255, 0)
        start_byte += 43
        for i in range(0, self.nb_ref_stations):
            self._ref_stations.append(self.Ref_StationsClass().decode_payload(payload, start_byte))
            start_byte += self.Ref_StationsClass.size()

        return self, start_byte

    def encode_payload(self) -> bytearray:
        buf_size = self.DEFAULT_BUFFER_SIZE
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._time, 0xffffffff, 0.0001)
        v1 = convert_to_int(self._latitude, 0x7fffffffffffffff, 1e-16)
        v2 = convert_to_int(self._longitude, 0x7fffffffffffffff, 1e-16)
        v3 = convert_to_int(self._altitude, 0x7fffffffffffffff, 1e-06)
        v4 = (self._GNSS_type & 0xf) << 0
        v4 |= (self._method & 0xf) << 4
        v5 = (self._integrity & 0x3) << 0
        v5 |= 0x3f << 2
        v6 = convert_to_int(self._HDOP, 0x7fff, 0.01)
        v7 = convert_to_int(self._PDOP, 0x7fff, 0.01)
        v8 = convert_to_int(self._geoidal_separation, 0x7fffffff, 0.01)
        self._struct_str_0.pack_into(buffer, start_byte, self._sequence_id, self._date, v0, v1, v2, v3, v4, v5, self._number_of_sv, v6, v7, v8, self._nb_ref_stations)
        start_byte += 43
        for repeat_field in self._ref_stations:
            start_byte = repeat_field.encode_payload(buffer, start_byte)

        return buffer[:start_byte]

    def from_protobuf(self, message: Pgn129029ClassPb):
        self._sequence_id = message.sequence_id
        self._date = message.date
        self._time = message.time
        self._latitude = message.latitude
        self._longitude = message.longitude
        self._altitude = message.altitude
        self._GNSS_type = message.GNSS_type
        self._method = message.method
        self._integrity = message.integrity
        self._number_of_sv = message.number_of_sv
        self._HDOP = message.HDOP
        self._PDOP = message.PDOP
        self._geoidal_separation = message.geoidal_separation
        self._nb_ref_stations = message.nb_ref_stations
        for sub_set in message.ref_stations:
            self._ref_stations.append(self.Ref_StationsClass(protobuf=sub_set))
        self.nb_ref_stations = len(self._ref_stations)

    def as_protobuf(self) -> Pgn129029ClassPb:
        message = Pgn129029ClassPb()
        message.sequence_id = self._sequence_id
        message.date = self._date
        message.time = self._time
        message.latitude = self._latitude
        message.longitude = self._longitude
        message.altitude = self._altitude
        message.GNSS_type = self._GNSS_type
        message.method = self._method
        message.integrity = self._integrity
        message.number_of_sv = self._number_of_sv
        message.HDOP = self._HDOP
        message.PDOP = self._PDOP
        message.geoidal_separation = self._geoidal_separation
        message.nb_ref_stations = self._nb_ref_stations
        for sub_set in self._ref_stations:
            message.ref_stations.append(sub_set.as_protobuf())
        self.nb_ref_stations = len(self._ref_stations)
        return message

    def set_protobuf(self, message: Pgn129029ClassPb):
        message.sequence_id = self._sequence_id
        message.date = self._date
        message.time = self._time
        message.latitude = self._latitude
        message.longitude = self._longitude
        message.altitude = self._altitude
        message.GNSS_type = self._GNSS_type
        message.method = self._method
        message.integrity = self._integrity
        message.number_of_sv = self._number_of_sv
        message.HDOP = self._HDOP
        message.PDOP = self._PDOP
        message.geoidal_separation = self._geoidal_separation
        message.nb_ref_stations = self._nb_ref_stations
        for sub_set in self._ref_stations:
            message.ref_stations.append(sub_set.as_protobuf())
        self.nb_ref_stations = len(self._ref_stations)

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129029ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, date={self._date}, time={self._time}, latitude={self._latitude}, longitude={self._longitude}, altitude={self._altitude}, GNSS_type={self._GNSS_type}, method={self._method}, integrity={self._integrity}, number_of_sv={self._number_of_sv}, HDOP={self._HDOP}, PDOP={self._PDOP}, geoidal_separation={self._geoidal_separation}, nb_ref_stations={self._nb_ref_stations}, ref_stations={self._ref_stations}]'


class Pgn129038Class(NMEA2000DecodedMsg):

    _pgn = 129038
    _name = 'AIS Class A Position Report'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129038ClassPb

    _struct_str_0 = struct.Struct('<BiiiBHHHBHHBB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_longitude', '_latitude', '_position_accuracy', '_RAIM', '_report_timestamp', '_COG', '_SOG', '_communication_state', '_transceiver_information', '_heading', '_rate_of_turn', '_navigation_status')

    _static_size = 27

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = 'AIS Repeat Indicator'
    _position_accuracy_enum = {
        0: 'Low',
        1: 'High'
        }
    _RAIM_enum = {
        0: 'not in use',
        1: 'in use'
        }
    _report_timestamp_enum = {
        60: 'Not available',
        61: 'Manual input mode',
        62: 'Dead reckoning mode',
        63: 'Positioning system is inoperative'
        }
    _transceiver_information_enum = 'AIS Transceiver information'
    _navigation_status_enum = {
        0: 'Under way using engine',
        1: 'At anchor',
        2: 'Not under command',
        3: 'Restricted manoeuverability',
        4: 'Constrained by her draught',
        5: 'Moored',
        6: 'Aground',
        7: 'Engaged in Fishing',
        8: 'Under way sailing'
        }
    _json_format = (
        GenericFormatter('_message_id', 'Message ID', 0x3f),
        EnumFormatter('_repeat_indicator', 'Repeat Indicator', 0x3, global_enum ='AIS Repeat Indicator' ),
        GenericFormatter('_mmsi', 'User ID', 0x7fffffff),
        FloatFormatter('_longitude', 'Longitude', '{:.6f}'),
        FloatFormatter('_latitude', 'Latitude', '{:.6f}'),
        EnumFormatter('_position_accuracy', 'Position Accuracy', 0x1, local = _position_accuracy_enum ),
        EnumFormatter('_RAIM', 'RAIM', 0x1, local = _RAIM_enum ),
        EnumFormatter('_report_timestamp', 'Time Stamp', 0x3f, local = _report_timestamp_enum ),
        FloatFormatter('_COG', 'COG', '{:.4f}'),
        FloatFormatter('_SOG', 'SOG', '{:.2f}'),
        GenericFormatter('_communication_state', 'Communication State', 0x7ffff),
        EnumFormatter('_transceiver_information', 'AIS Transceiver information', 0x1f, global_enum ='AIS Transceiver information' ),
        FloatFormatter('_heading', 'Heading', '{:.4f}'),
        FloatFormatter('_rate_of_turn', 'Rate of Turn', '{:.4f}'),
        EnumFormatter('_navigation_status', 'Nav Status', 0xff, local = _navigation_status_enum )
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def longitude(self) -> float:
        return self._longitude

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def position_accuracy(self) -> int:
        return self._position_accuracy

    @property
    def RAIM(self) -> int:
        return self._RAIM

    @property
    def report_timestamp(self) -> int:
        return self._report_timestamp

    @property
    def COG(self) -> float:
        return self._COG

    @property
    def SOG(self) -> float:
        return self._SOG

    @property
    def communication_state(self) -> int:
        return self._communication_state

    @property
    def transceiver_information(self) -> int:
        return self._transceiver_information

    @property
    def heading(self) -> float:
        return self._heading

    @property
    def rate_of_turn(self) -> float:
        return self._rate_of_turn

    @property
    def navigation_status(self) -> int:
        return self._navigation_status

    @message_id.setter
    def message_id(self, value: int):
        self._message_id = value

    @repeat_indicator.setter
    def repeat_indicator(self, value: int):
        self._repeat_indicator = value

    @mmsi.setter
    def mmsi(self, value: int):
        self._mmsi = value

    @longitude.setter
    def longitude(self, value: float):
        self._longitude = value

    @latitude.setter
    def latitude(self, value: float):
        self._latitude = value

    @position_accuracy.setter
    def position_accuracy(self, value: int):
        self._position_accuracy = value

    @RAIM.setter
    def RAIM(self, value: int):
        self._RAIM = value

    @report_timestamp.setter
    def report_timestamp(self, value: int):
        self._report_timestamp = value

    @COG.setter
    def COG(self, value: float):
        self._COG = value

    @SOG.setter
    def SOG(self, value: float):
        self._SOG = value

    @communication_state.setter
    def communication_state(self, value: int):
        self._communication_state = value

    @transceiver_information.setter
    def transceiver_information(self, value: int):
        self._transceiver_information = value

    @heading.setter
    def heading(self, value: float):
        self._heading = value

    @rate_of_turn.setter
    def rate_of_turn(self, value: float):
        self._rate_of_turn = value

    @navigation_status.setter
    def navigation_status(self, value: int):
        self._navigation_status = value

    @property
    def repeat_indicator_text(self) -> str:
        return resolve_global_enum(self._repeat_indicator_enum, self._repeat_indicator)

    @property
    def position_accuracy_text(self) -> str:
        return self._position_accuracy_enum.get(self._position_accuracy, 'position_accuracy key error')

    @property
    def RAIM_text(self) -> str:
        return self._RAIM_enum.get(self._RAIM, 'RAIM key error')

    @property
    def report_timestamp_text(self) -> str:
        return self._report_timestamp_enum.get(self._report_timestamp, 'report_timestamp key error')

    @property
    def transceiver_information_text(self) -> str:
        return resolve_global_enum(self._transceiver_information_enum, self._transceiver_information)

    @property
    def navigation_status_text(self) -> str:
        return self._navigation_status_enum.get(self._navigation_status, 'navigation_status key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._longitude = check_convert_float(val[2], 0x7fffffff, 1e-07)
        self._latitude = check_convert_float(val[3], 0x7fffffff, 1e-07)
        self._position_accuracy = val[4] & 0x1
        self._RAIM = (val[4] >> 1) & 0x1
        self._report_timestamp = (val[4] >> 2) & 0x3F
        self._COG = check_convert_float(val[5], 0xffff, 0.0001)
        self._SOG = check_convert_float(val[6], 0xffff, 0.01)
        word = val[7] + (val[8] << 16)
        self._communication_state = word & 0x7FFFF
        self._transceiver_information = (word >> 19) & 0x1F
        self._heading = check_convert_float(val[9], 0xffff, 0.0001)
        self._rate_of_turn = check_convert_float(val[10], 0xffff, 0.0001)
        self._navigation_status = val[11]
        start_byte += 27
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        v1 = convert_to_int(self._longitude, 0x7fffffff, 1e-07)
        v2 = convert_to_int(self._latitude, 0x7fffffff, 1e-07)
        v3 = (self._position_accuracy & 0x1) << 0
        v3 |= (self._RAIM & 0x1) << 1
        v3 |= (self._report_timestamp & 0x3f) << 2
        v4 = convert_to_int(self._COG, 0xffff, 0.0001)
        v5 = convert_to_int(self._SOG, 0xffff, 0.01)
        word = (self._communication_state & 0x7ffff) << 0
        word |= (self._transceiver_information & 0x1f) << 19
        v6 = word & 0xFFFF
        v7 = (word & 0xFF) >> 16
        v8 = convert_to_int(self._heading, 0xffff, 0.0001)
        v9 = convert_to_int(self._rate_of_turn, 0xffff, 0.0001)
        v10 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi, v1, v2, v3, v4, v5, v6, v7, v8, v9, self._navigation_status, v10)
        return buffer

    def from_protobuf(self, message: Pgn129038ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._longitude = message.longitude
        self._latitude = message.latitude
        self._position_accuracy = message.position_accuracy
        self._RAIM = message.RAIM
        self._report_timestamp = message.report_timestamp
        self._COG = message.COG
        self._SOG = message.SOG
        self._communication_state = message.communication_state
        self._transceiver_information = message.transceiver_information
        self._heading = message.heading
        self._rate_of_turn = message.rate_of_turn
        self._navigation_status = message.navigation_status

    def as_protobuf(self) -> Pgn129038ClassPb:
        message = Pgn129038ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.longitude = self._longitude
        message.latitude = self._latitude
        message.position_accuracy = self._position_accuracy
        message.RAIM = self._RAIM
        message.report_timestamp = self._report_timestamp
        message.COG = self._COG
        message.SOG = self._SOG
        message.communication_state = self._communication_state
        message.transceiver_information = self._transceiver_information
        message.heading = self._heading
        message.rate_of_turn = self._rate_of_turn
        message.navigation_status = self._navigation_status
        return message

    def set_protobuf(self, message: Pgn129038ClassPb):
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.longitude = self._longitude
        message.latitude = self._latitude
        message.position_accuracy = self._position_accuracy
        message.RAIM = self._RAIM
        message.report_timestamp = self._report_timestamp
        message.COG = self._COG
        message.SOG = self._SOG
        message.communication_state = self._communication_state
        message.transceiver_information = self._transceiver_information
        message.heading = self._heading
        message.rate_of_turn = self._rate_of_turn
        message.navigation_status = self._navigation_status

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129038ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, longitude={self._longitude}, latitude={self._latitude}, position_accuracy={self._position_accuracy}, RAIM={self._RAIM}, report_timestamp={self._report_timestamp}, COG={self._COG}, SOG={self._SOG}, communication_state={self._communication_state}, transceiver_information={self._transceiver_information}, heading={self._heading}, rate_of_turn={self._rate_of_turn}, navigation_status={self._navigation_status}]'


class Pgn129039Class(NMEA2000DecodedMsg):

    _pgn = 129039
    _name = 'AIS Class B Position Report'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129039ClassPb

    _struct_str_0 = struct.Struct('<BiiiBHHHBHBBH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_longitude', '_latitude', '_position_accuracy', '_RAIM', '_report_timestamp', '_COG', '_SOG', '_communication_state', '_transceiver_info', '_heading', '_unit_type', '_band', '_handle_msg22', '_AIS_mode', '_AIS_communication_state')

    _static_size = 27

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = 'AIS Repeat Indicator'
    _position_accuracy_enum = {
        0: 'Low',
        1: 'High'
        }
    _RAIM_enum = {
        0: 'not in use',
        1: 'in use'
        }
    _report_timestamp_enum = {
        60: 'Not available',
        61: 'Manual input mode',
        62: 'Dead reckoning mode',
        63: 'Positioning system is inoperative'
        }
    _transceiver_info_enum = 'AIS Transceiver information'
    _unit_type_enum = {
        0: 'SOTDMA',
        1: 'CS'
        }
    _band_enum = {
        0: 'top 525 kHz of marine band',
        1: 'entire marine band'
        }
    _handle_msg22_enum = {
        0: 'No',
        1: 'Yes'
        }
    _AIS_mode_enum = {
        0: 'Autonomous',
        1: 'Assigned'
        }
    _AIS_communication_state_enum = {
        0: 'SOTDMA',
        1: 'ITDMA'
        }
    _json_format = (
        GenericFormatter('_message_id', 'Message ID', 0x3f),
        EnumFormatter('_repeat_indicator', 'Repeat Indicator', 0x3, global_enum ='AIS Repeat Indicator' ),
        GenericFormatter('_mmsi', 'User ID', 0x7fffffff),
        FloatFormatter('_longitude', 'Longitude', '{:.6f}'),
        FloatFormatter('_latitude', 'Latitude', '{:.6f}'),
        EnumFormatter('_position_accuracy', 'Position Accuracy', 0x1, local = _position_accuracy_enum ),
        EnumFormatter('_RAIM', 'RAIM', 0x1, local = _RAIM_enum ),
        EnumFormatter('_report_timestamp', 'Time Stamp', 0x3f, local = _report_timestamp_enum ),
        FloatFormatter('_COG', 'COG', '{:.4f}'),
        FloatFormatter('_SOG', 'SOG', '{:.2f}'),
        GenericFormatter('_communication_state', 'Communication State', 0x7ffff),
        EnumFormatter('_transceiver_info', 'AIS Transceiver information', 0x1f, global_enum ='AIS Transceiver information' ),
        FloatFormatter('_heading', 'Heading', '{:.4f}'),
        EnumFormatter('_unit_type', 'Unit type', 0x1, local = _unit_type_enum ),
        EnumFormatter('_band', 'Band', 0x1, local = _band_enum ),
        EnumFormatter('_handle_msg22', 'Can handle Msg 22', 0x1, local = _handle_msg22_enum ),
        EnumFormatter('_AIS_mode', 'AIS mode', 0x1, local = _AIS_mode_enum ),
        EnumFormatter('_AIS_communication_state', 'AIS communication state', 0x1, local = _AIS_communication_state_enum )
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def longitude(self) -> float:
        return self._longitude

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def position_accuracy(self) -> int:
        return self._position_accuracy

    @property
    def RAIM(self) -> int:
        return self._RAIM

    @property
    def report_timestamp(self) -> int:
        return self._report_timestamp

    @property
    def COG(self) -> float:
        return self._COG

    @property
    def SOG(self) -> float:
        return self._SOG

    @property
    def communication_state(self) -> int:
        return self._communication_state

    @property
    def transceiver_info(self) -> int:
        return self._transceiver_info

    @property
    def heading(self) -> float:
        return self._heading

    @property
    def unit_type(self) -> int:
        return self._unit_type

    @property
    def band(self) -> int:
        return self._band

    @property
    def handle_msg22(self) -> int:
        return self._handle_msg22

    @property
    def AIS_mode(self) -> int:
        return self._AIS_mode

    @property
    def AIS_communication_state(self) -> int:
        return self._AIS_communication_state

    @message_id.setter
    def message_id(self, value: int):
        self._message_id = value

    @repeat_indicator.setter
    def repeat_indicator(self, value: int):
        self._repeat_indicator = value

    @mmsi.setter
    def mmsi(self, value: int):
        self._mmsi = value

    @longitude.setter
    def longitude(self, value: float):
        self._longitude = value

    @latitude.setter
    def latitude(self, value: float):
        self._latitude = value

    @position_accuracy.setter
    def position_accuracy(self, value: int):
        self._position_accuracy = value

    @RAIM.setter
    def RAIM(self, value: int):
        self._RAIM = value

    @report_timestamp.setter
    def report_timestamp(self, value: int):
        self._report_timestamp = value

    @COG.setter
    def COG(self, value: float):
        self._COG = value

    @SOG.setter
    def SOG(self, value: float):
        self._SOG = value

    @communication_state.setter
    def communication_state(self, value: int):
        self._communication_state = value

    @transceiver_info.setter
    def transceiver_info(self, value: int):
        self._transceiver_info = value

    @heading.setter
    def heading(self, value: float):
        self._heading = value

    @unit_type.setter
    def unit_type(self, value: int):
        self._unit_type = value

    @band.setter
    def band(self, value: int):
        self._band = value

    @handle_msg22.setter
    def handle_msg22(self, value: int):
        self._handle_msg22 = value

    @AIS_mode.setter
    def AIS_mode(self, value: int):
        self._AIS_mode = value

    @AIS_communication_state.setter
    def AIS_communication_state(self, value: int):
        self._AIS_communication_state = value

    @property
    def repeat_indicator_text(self) -> str:
        return resolve_global_enum(self._repeat_indicator_enum, self._repeat_indicator)

    @property
    def position_accuracy_text(self) -> str:
        return self._position_accuracy_enum.get(self._position_accuracy, 'position_accuracy key error')

    @property
    def RAIM_text(self) -> str:
        return self._RAIM_enum.get(self._RAIM, 'RAIM key error')

    @property
    def report_timestamp_text(self) -> str:
        return self._report_timestamp_enum.get(self._report_timestamp, 'report_timestamp key error')

    @property
    def transceiver_info_text(self) -> str:
        return resolve_global_enum(self._transceiver_info_enum, self._transceiver_info)

    @property
    def unit_type_text(self) -> str:
        return self._unit_type_enum.get(self._unit_type, 'unit_type key error')

    @property
    def band_text(self) -> str:
        return self._band_enum.get(self._band, 'band key error')

    @property
    def handle_msg22_text(self) -> str:
        return self._handle_msg22_enum.get(self._handle_msg22, 'handle_msg22 key error')

    @property
    def AIS_mode_text(self) -> str:
        return self._AIS_mode_enum.get(self._AIS_mode, 'AIS_mode key error')

    @property
    def AIS_communication_state_text(self) -> str:
        return self._AIS_communication_state_enum.get(self._AIS_communication_state, 'AIS_communication_state key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._longitude = check_convert_float(val[2], 0x7fffffff, 1e-07)
        self._latitude = check_convert_float(val[3], 0x7fffffff, 1e-07)
        self._position_accuracy = val[4] & 0x1
        self._RAIM = (val[4] >> 1) & 0x1
        self._report_timestamp = (val[4] >> 2) & 0x3F
        self._COG = check_convert_float(val[5], 0xffff, 0.0001)
        self._SOG = check_convert_float(val[6], 0xffff, 0.01)
        word = val[7] + (val[8] << 16)
        self._communication_state = word & 0x7FFFF
        self._transceiver_info = (word >> 19) & 0x1F
        self._heading = check_convert_float(val[9], 0xffff, 0.0001)
        self._unit_type = (val[11] >> 2) & 0x1
        self._band = (val[11] >> 5) & 0x1
        self._handle_msg22 = (val[11] >> 6) & 0x1
        self._AIS_mode = (val[11] >> 7) & 0x1
        self._AIS_communication_state = val[12] & 0x1
        start_byte += 27
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        v1 = convert_to_int(self._longitude, 0x7fffffff, 1e-07)
        v2 = convert_to_int(self._latitude, 0x7fffffff, 1e-07)
        v3 = (self._position_accuracy & 0x1) << 0
        v3 |= (self._RAIM & 0x1) << 1
        v3 |= (self._report_timestamp & 0x3f) << 2
        v4 = convert_to_int(self._COG, 0xffff, 0.0001)
        v5 = convert_to_int(self._SOG, 0xffff, 0.01)
        word = (self._communication_state & 0x7ffff) << 0
        word |= (self._transceiver_info & 0x1f) << 19
        v6 = word & 0xFFFF
        v7 = (word & 0xFF) >> 16
        v8 = convert_to_int(self._heading, 0xffff, 0.0001)
        v9 = 0xff
        v10 = 0x3 << 0
        v10 |= (self._unit_type & 0x1) << 2
        v10 |= 0x1 << 3
        v10 |= 0x1 << 4
        v10 |= (self._band & 0x1) << 5
        v10 |= (self._handle_msg22 & 0x1) << 6
        v10 |= (self._AIS_mode & 0x1) << 7
        v11 = (self._AIS_communication_state & 0x1) << 0
        v11 |= 0x7fff << 1
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
        return buffer

    def from_protobuf(self, message: Pgn129039ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._longitude = message.longitude
        self._latitude = message.latitude
        self._position_accuracy = message.position_accuracy
        self._RAIM = message.RAIM
        self._report_timestamp = message.report_timestamp
        self._COG = message.COG
        self._SOG = message.SOG
        self._communication_state = message.communication_state
        self._transceiver_info = message.transceiver_info
        self._heading = message.heading
        self._unit_type = message.unit_type
        self._band = message.band
        self._handle_msg22 = message.handle_msg22
        self._AIS_mode = message.AIS_mode
        self._AIS_communication_state = message.AIS_communication_state

    def as_protobuf(self) -> Pgn129039ClassPb:
        message = Pgn129039ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.longitude = self._longitude
        message.latitude = self._latitude
        message.position_accuracy = self._position_accuracy
        message.RAIM = self._RAIM
        message.report_timestamp = self._report_timestamp
        message.COG = self._COG
        message.SOG = self._SOG
        message.communication_state = self._communication_state
        message.transceiver_info = self._transceiver_info
        message.heading = self._heading
        message.unit_type = self._unit_type
        message.band = self._band
        message.handle_msg22 = self._handle_msg22
        message.AIS_mode = self._AIS_mode
        message.AIS_communication_state = self._AIS_communication_state
        return message

    def set_protobuf(self, message: Pgn129039ClassPb):
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.longitude = self._longitude
        message.latitude = self._latitude
        message.position_accuracy = self._position_accuracy
        message.RAIM = self._RAIM
        message.report_timestamp = self._report_timestamp
        message.COG = self._COG
        message.SOG = self._SOG
        message.communication_state = self._communication_state
        message.transceiver_info = self._transceiver_info
        message.heading = self._heading
        message.unit_type = self._unit_type
        message.band = self._band
        message.handle_msg22 = self._handle_msg22
        message.AIS_mode = self._AIS_mode
        message.AIS_communication_state = self._AIS_communication_state

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129039ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, longitude={self._longitude}, latitude={self._latitude}, position_accuracy={self._position_accuracy}, RAIM={self._RAIM}, report_timestamp={self._report_timestamp}, COG={self._COG}, SOG={self._SOG}, communication_state={self._communication_state}, transceiver_info={self._transceiver_info}, heading={self._heading}, unit_type={self._unit_type}, band={self._band}, handle_msg22={self._handle_msg22}, AIS_mode={self._AIS_mode}, AIS_communication_state={self._AIS_communication_state}]'


class Pgn129283Class(NMEA2000DecodedMsg):

    _pgn = 129283
    _name = 'Cross Track Error'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129283ClassPb

    _struct_str_0 = struct.Struct('<BBi')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_XTE_mode', '_navigation_terminated', '_XTE')

    _static_size = 6

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _XTE_mode_enum = {
        0: 'Autonomous',
        1: 'Differential enhanced',
        2: 'Estimated',
        3: 'Simulator',
        4: 'Manual'
        }
    _navigation_terminated_enum = {
        0: 'No',
        1: 'Yes'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        EnumFormatter('_XTE_mode', 'XTE mode', 0xf, local = _XTE_mode_enum ),
        EnumFormatter('_navigation_terminated', 'Navigation Terminated', 0x3, local = _navigation_terminated_enum ),
        FloatFormatter('_XTE', 'XTE', '{:.1f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def XTE_mode(self) -> int:
        return self._XTE_mode

    @property
    def navigation_terminated(self) -> int:
        return self._navigation_terminated

    @property
    def XTE(self) -> float:
        return self._XTE

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @XTE_mode.setter
    def XTE_mode(self, value: int):
        self._XTE_mode = value

    @navigation_terminated.setter
    def navigation_terminated(self, value: int):
        self._navigation_terminated = value

    @XTE.setter
    def XTE(self, value: float):
        self._XTE = value

    @property
    def XTE_mode_text(self) -> str:
        return self._XTE_mode_enum.get(self._XTE_mode, 'XTE_mode key error')

    @property
    def navigation_terminated_text(self) -> str:
        return self._navigation_terminated_enum.get(self._navigation_terminated, 'navigation_terminated key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._XTE_mode = val[1] & 0xF
        self._navigation_terminated = (val[1] >> 6) & 0x3
        self._XTE = check_convert_float(val[2], 0x7fffffff, 0.01)
        start_byte += 6
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._XTE_mode & 0xf) << 0
        v0 |= 0x3 << 4
        v0 |= (self._navigation_terminated & 0x3) << 6
        v1 = convert_to_int(self._XTE, 0x7fffffff, 0.01)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn129283ClassPb):
        self._sequence_id = message.sequence_id
        self._XTE_mode = message.XTE_mode
        self._navigation_terminated = message.navigation_terminated
        self._XTE = message.XTE

    def as_protobuf(self) -> Pgn129283ClassPb:
        message = Pgn129283ClassPb()
        message.sequence_id = self._sequence_id
        message.XTE_mode = self._XTE_mode
        message.navigation_terminated = self._navigation_terminated
        message.XTE = self._XTE
        return message

    def set_protobuf(self, message: Pgn129283ClassPb):
        message.sequence_id = self._sequence_id
        message.XTE_mode = self._XTE_mode
        message.navigation_terminated = self._navigation_terminated
        message.XTE = self._XTE

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129283ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, XTE_mode={self._XTE_mode}, navigation_terminated={self._navigation_terminated}, XTE={self._XTE}]'


class Pgn129284Class(NMEA2000DecodedMsg):

    _pgn = 129284
    _name = 'Navigation Data'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129284ClassPb

    _struct_str_0 = struct.Struct('<BIBIHHHIIiih')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_distance_to_waypoint', '_bearing_reference', '_perpendicular_crossed', '_arrival_circle_entered', '_calculation_type', '_ETA_time', '_ETA_date', '_bearing_origin_to_destination', '_bearing_position_to_destination', '_origin_waypoint', '_destination_waypoint', '_destination_latitude', '_destination_longitude', '_WCV')

    _static_size = 34

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _bearing_reference_enum = {
        0: 'True',
        1: 'Magnetic'
        }
    _perpendicular_crossed_enum = {
        0: 'No',
        1: 'Yes'
        }
    _arrival_circle_entered_enum = {
        0: 'No',
        1: 'Yes'
        }
    _calculation_type_enum = {
        0: 'Great Circle',
        1: 'Rhumb Line'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        FloatFormatter('_distance_to_waypoint', 'Distance to Waypoint', '{:.1f}'),
        EnumFormatter('_bearing_reference', 'Course/Bearing reference', 0x3, local = _bearing_reference_enum ),
        EnumFormatter('_perpendicular_crossed', 'Perpendicular Crossed', 0x3, local = _perpendicular_crossed_enum ),
        EnumFormatter('_arrival_circle_entered', 'Arrival Circle Entered', 0x3, local = _arrival_circle_entered_enum ),
        EnumFormatter('_calculation_type', 'Calculation Type', 0x3, local = _calculation_type_enum ),
        FloatFormatter('_ETA_time', 'ETA Time', '{:.2f}'),
        GenericFormatter('_ETA_date', 'ETA Date', 0xffff),
        FloatFormatter('_bearing_origin_to_destination', 'Bearing, Origin to Destination Waypoint', '{:.4f}'),
        FloatFormatter('_bearing_position_to_destination', 'Bearing, Position to Destination Waypoint', '{:.4f}'),
        GenericFormatter('_origin_waypoint', 'Origin Waypoint Number', 0xffffffff),
        GenericFormatter('_destination_waypoint', 'Destination Waypoint Number', 0xffffffff),
        FloatFormatter('_destination_latitude', 'Destination Latitude', '{:.6f}'),
        FloatFormatter('_destination_longitude', 'Destination Longitude', '{:.6f}'),
        FloatFormatter('_WCV', 'Waypoint Closing Velocity', '{:.2f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def distance_to_waypoint(self) -> float:
        return self._distance_to_waypoint

    @property
    def bearing_reference(self) -> int:
        return self._bearing_reference

    @property
    def perpendicular_crossed(self) -> int:
        return self._perpendicular_crossed

    @property
    def arrival_circle_entered(self) -> int:
        return self._arrival_circle_entered

    @property
    def calculation_type(self) -> int:
        return self._calculation_type

    @property
    def ETA_time(self) -> float:
        return self._ETA_time

    @property
    def ETA_date(self) -> int:
        return self._ETA_date

    @property
    def bearing_origin_to_destination(self) -> float:
        return self._bearing_origin_to_destination

    @property
    def bearing_position_to_destination(self) -> float:
        return self._bearing_position_to_destination

    @property
    def origin_waypoint(self) -> int:
        return self._origin_waypoint

    @property
    def destination_waypoint(self) -> int:
        return self._destination_waypoint

    @property
    def destination_latitude(self) -> float:
        return self._destination_latitude

    @property
    def destination_longitude(self) -> float:
        return self._destination_longitude

    @property
    def WCV(self) -> float:
        return self._WCV

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @distance_to_waypoint.setter
    def distance_to_waypoint(self, value: float):
        self._distance_to_waypoint = value

    @bearing_reference.setter
    def bearing_reference(self, value: int):
        self._bearing_reference = value

    @perpendicular_crossed.setter
    def perpendicular_crossed(self, value: int):
        self._perpendicular_crossed = value

    @arrival_circle_entered.setter
    def arrival_circle_entered(self, value: int):
        self._arrival_circle_entered = value

    @calculation_type.setter
    def calculation_type(self, value: int):
        self._calculation_type = value

    @ETA_time.setter
    def ETA_time(self, value: float):
        self._ETA_time = value

    @ETA_date.setter
    def ETA_date(self, value: int):
        self._ETA_date = value

    @bearing_origin_to_destination.setter
    def bearing_origin_to_destination(self, value: float):
        self._bearing_origin_to_destination = value

    @bearing_position_to_destination.setter
    def bearing_position_to_destination(self, value: float):
        self._bearing_position_to_destination = value

    @origin_waypoint.setter
    def origin_waypoint(self, value: int):
        self._origin_waypoint = value

    @destination_waypoint.setter
    def destination_waypoint(self, value: int):
        self._destination_waypoint = value

    @destination_latitude.setter
    def destination_latitude(self, value: float):
        self._destination_latitude = value

    @destination_longitude.setter
    def destination_longitude(self, value: float):
        self._destination_longitude = value

    @WCV.setter
    def WCV(self, value: float):
        self._WCV = value

    @property
    def bearing_reference_text(self) -> str:
        return self._bearing_reference_enum.get(self._bearing_reference, 'bearing_reference key error')

    @property
    def perpendicular_crossed_text(self) -> str:
        return self._perpendicular_crossed_enum.get(self._perpendicular_crossed, 'perpendicular_crossed key error')

    @property
    def arrival_circle_entered_text(self) -> str:
        return self._arrival_circle_entered_enum.get(self._arrival_circle_entered, 'arrival_circle_entered key error')

    @property
    def calculation_type_text(self) -> str:
        return self._calculation_type_enum.get(self._calculation_type, 'calculation_type key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._distance_to_waypoint = check_convert_float(val[1], 0xffffffff, 0.01)
        self._bearing_reference = val[2] & 0x3
        self._perpendicular_crossed = (val[2] >> 2) & 0x3
        self._arrival_circle_entered = (val[2] >> 4) & 0x3
        self._calculation_type = (val[2] >> 6) & 0x3
        self._ETA_time = check_convert_float(val[3], 0xffffffff, 0.0001)
        self._ETA_date = val[4]
        self._bearing_origin_to_destination = check_convert_float(val[5], 0xffff, 0.001)
        self._bearing_position_to_destination = check_convert_float(val[6], 0xffff, 0.0001)
        self._origin_waypoint = val[7]
        self._destination_waypoint = val[8]
        self._destination_latitude = check_convert_float(val[9], 0x7fffffff, 1e-07)
        self._destination_longitude = check_convert_float(val[10], 0x7fffffff, 1e-07)
        self._WCV = check_convert_float(val[11], 0x7fff, 0.01)
        start_byte += 34
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._distance_to_waypoint, 0xffffffff, 0.01)
        v1 = (self._bearing_reference & 0x3) << 0
        v1 |= (self._perpendicular_crossed & 0x3) << 2
        v1 |= (self._arrival_circle_entered & 0x3) << 4
        v1 |= (self._calculation_type & 0x3) << 6
        v2 = convert_to_int(self._ETA_time, 0xffffffff, 0.0001)
        v3 = convert_to_int(self._bearing_origin_to_destination, 0xffff, 0.001)
        v4 = convert_to_int(self._bearing_position_to_destination, 0xffff, 0.0001)
        v5 = convert_to_int(self._destination_latitude, 0x7fffffff, 1e-07)
        v6 = convert_to_int(self._destination_longitude, 0x7fffffff, 1e-07)
        v7 = convert_to_int(self._WCV, 0x7fff, 0.01)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, v2, self._ETA_date, v3, v4, self._origin_waypoint, self._destination_waypoint, v5, v6, v7)
        return buffer

    def from_protobuf(self, message: Pgn129284ClassPb):
        self._sequence_id = message.sequence_id
        self._distance_to_waypoint = message.distance_to_waypoint
        self._bearing_reference = message.bearing_reference
        self._perpendicular_crossed = message.perpendicular_crossed
        self._arrival_circle_entered = message.arrival_circle_entered
        self._calculation_type = message.calculation_type
        self._ETA_time = message.ETA_time
        self._ETA_date = message.ETA_date
        self._bearing_origin_to_destination = message.bearing_origin_to_destination
        self._bearing_position_to_destination = message.bearing_position_to_destination
        self._origin_waypoint = message.origin_waypoint
        self._destination_waypoint = message.destination_waypoint
        self._destination_latitude = message.destination_latitude
        self._destination_longitude = message.destination_longitude
        self._WCV = message.WCV

    def as_protobuf(self) -> Pgn129284ClassPb:
        message = Pgn129284ClassPb()
        message.sequence_id = self._sequence_id
        message.distance_to_waypoint = self._distance_to_waypoint
        message.bearing_reference = self._bearing_reference
        message.perpendicular_crossed = self._perpendicular_crossed
        message.arrival_circle_entered = self._arrival_circle_entered
        message.calculation_type = self._calculation_type
        message.ETA_time = self._ETA_time
        message.ETA_date = self._ETA_date
        message.bearing_origin_to_destination = self._bearing_origin_to_destination
        message.bearing_position_to_destination = self._bearing_position_to_destination
        message.origin_waypoint = self._origin_waypoint
        message.destination_waypoint = self._destination_waypoint
        message.destination_latitude = self._destination_latitude
        message.destination_longitude = self._destination_longitude
        message.WCV = self._WCV
        return message

    def set_protobuf(self, message: Pgn129284ClassPb):
        message.sequence_id = self._sequence_id
        message.distance_to_waypoint = self._distance_to_waypoint
        message.bearing_reference = self._bearing_reference
        message.perpendicular_crossed = self._perpendicular_crossed
        message.arrival_circle_entered = self._arrival_circle_entered
        message.calculation_type = self._calculation_type
        message.ETA_time = self._ETA_time
        message.ETA_date = self._ETA_date
        message.bearing_origin_to_destination = self._bearing_origin_to_destination
        message.bearing_position_to_destination = self._bearing_position_to_destination
        message.origin_waypoint = self._origin_waypoint
        message.destination_waypoint = self._destination_waypoint
        message.destination_latitude = self._destination_latitude
        message.destination_longitude = self._destination_longitude
        message.WCV = self._WCV

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129284ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, distance_to_waypoint={self._distance_to_waypoint}, bearing_reference={self._bearing_reference}, perpendicular_crossed={self._perpendicular_crossed}, arrival_circle_entered={self._arrival_circle_entered}, calculation_type={self._calculation_type}, ETA_time={self._ETA_time}, ETA_date={self._ETA_date}, bearing_origin_to_destination={self._bearing_origin_to_destination}, bearing_position_to_destination={self._bearing_position_to_destination}, origin_waypoint={self._origin_waypoint}, destination_waypoint={self._destination_waypoint}, destination_latitude={self._destination_latitude}, destination_longitude={self._destination_longitude}, WCV={self._WCV}]'


class Pgn129285Class(NMEA2000DecodedMsg):

    class Wp_DefinitionsClass:

        _struct_str_0 = struct.Struct('<H')
        _struct_str_0_size = _struct_str_0.size
        _struct_str_1 = struct.Struct('<ii')
        _struct_str_1_size = _struct_str_1.size
        __slots__ = ('_waypoint_id', '_waypoint_name', '_waypoint_latitude', '_waypoint_longitude')


        @staticmethod
        def variable_size() -> bool:
            return True



        _json_format = (
            GenericFormatter('_waypoint_id', 'WP ID', 0xffff),
            TextFormatter('_waypoint_name', 'WP Name'),
            FloatFormatter('_waypoint_latitude', 'WP Latitude', '{:.6f}'),
            FloatFormatter('_waypoint_longitude', 'WP Longitude', '{:.6f}')
            )

        def json_format(self):
            return self._json_format

        def __init__(self, protobuf=None):
            if protobuf is not None:
                self.from_protobuf(protobuf)

        @property
        def waypoint_id(self) -> int:
            return self._waypoint_id

        @property
        def waypoint_name(self) -> str:
            return self._waypoint_name

        @property
        def waypoint_latitude(self) -> float:
            return self._waypoint_latitude

        @property
        def waypoint_longitude(self) -> float:
            return self._waypoint_longitude

        @waypoint_id.setter
        def waypoint_id(self, value: int):
            self._waypoint_id = value

        @waypoint_name.setter
        def waypoint_name(self, value: str):
            self._waypoint_name = value

        @waypoint_latitude.setter
        def waypoint_latitude(self, value: float):
            self._waypoint_latitude = value

        @waypoint_longitude.setter
        def waypoint_longitude(self, value: float):
            self._waypoint_longitude = value

        def decode_payload(self, payload, start_byte=0):
            val = self._struct_str_0.unpack_from(payload, start_byte)
            self._waypoint_id = val[0]
            start_byte += 2
            dec_str, dec_str_len = extract_var_str(payload, start_byte)
            self._waypoint_name = dec_str
            start_byte += dec_str_len
            val = self._struct_str_1.unpack_from(payload, start_byte)
            self._waypoint_latitude = check_convert_float(val[0], 0x7fffffff, 1e-07)
            self._waypoint_longitude = check_convert_float(val[1], 0x7fffffff, 1e-07)
            start_byte += 8
            return self, start_byte

        def encode_payload(self, buffer, start_byte):
            self._struct_str_0.pack_into(buffer, start_byte, self._waypoint_id)
            start_byte += 2
            inserted_len = insert_var_str(buffer, start_byte, self._waypoint_name)
            start_byte += inserted_len
            v0 = convert_to_int(self._waypoint_latitude, 0x7fffffff, 1e-07)
            v1 = convert_to_int(self._waypoint_longitude, 0x7fffffff, 1e-07)
            self._struct_str_1.pack_into(buffer, start_byte, v0, v1)
            start_byte += 8
            return start_byte

        def from_protobuf(self, message: Pgn129285ClassPb.Wp_DefinitionsClassPb):
            self._waypoint_id = message.waypoint_id
            self._waypoint_name = message.waypoint_name
            self._waypoint_latitude = message.waypoint_latitude
            self._waypoint_longitude = message.waypoint_longitude

        def as_protobuf(self) -> Pgn129285ClassPb.Wp_DefinitionsClassPb:
            message = Pgn129285ClassPb.Wp_DefinitionsClassPb()
            message.waypoint_id = self._waypoint_id
            message.waypoint_name = self._waypoint_name
            message.waypoint_latitude = self._waypoint_latitude
            message.waypoint_longitude = self._waypoint_longitude
            return message

        def set_protobuf(self, message: Pgn129285ClassPb.Wp_DefinitionsClassPb):
            message.waypoint_id = self._waypoint_id
            message.waypoint_name = self._waypoint_name
            message.waypoint_latitude = self._waypoint_latitude
            message.waypoint_longitude = self._waypoint_longitude

        def __str__(self):
            return f'(Wp_DefinitionsClass) [waypoint_id={self._waypoint_id}, waypoint_name={self._waypoint_name}, waypoint_latitude={self._waypoint_latitude}, waypoint_longitude={self._waypoint_longitude}]'


    _pgn = 129285
    _name = 'Navigation - Route/WP Information'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129285ClassPb

    _struct_str_0 = struct.Struct('<HHHHB')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<B')
    _struct_str_1_size = _struct_str_1.size
    __slots__ = ('_start_waypoint_id', '_nb_items', '_database_id', '_route_id', '_navigation_direction', '_supplementary_data', '_route_name', '_WP_definitions')


    @staticmethod
    def variable_size() -> bool:
        return True

    _json_format = (
        GenericFormatter('_start_waypoint_id', 'Start RPS#', 0xffff),
        RepeatedFormatter('_nb_items', 'nItems', '_WP_definitions'),
        GenericFormatter('_database_id', 'Database ID', 0xffff),
        GenericFormatter('_route_id', 'Route ID', 0xffff),
        GenericFormatter('_navigation_direction', 'Navigation direction in route', 0x7),
        GenericFormatter('_supplementary_data', 'Supplementary Route/WP data available', 0x3),
        TextFormatter('_route_name', 'Route Name'),
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        self._nb_items = 0
        self._WP_definitions = []
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def start_waypoint_id(self) -> int:
        return self._start_waypoint_id

    @property
    def nb_items(self) -> int:
        return self._nb_items

    @property
    def database_id(self) -> int:
        return self._database_id

    @property
    def route_id(self) -> int:
        return self._route_id

    @property
    def navigation_direction(self) -> int:
        return self._navigation_direction

    @property
    def supplementary_data(self) -> int:
        return self._supplementary_data

    @property
    def route_name(self) -> str:
        return self._route_name

    @property
    def WP_definitions(self) -> list:
        return self._WP_definitions

    @start_waypoint_id.setter
    def start_waypoint_id(self, value: int):
        self._start_waypoint_id = value

    @nb_items.setter
    def nb_items(self, value: int):
        self._nb_items = value

    @database_id.setter
    def database_id(self, value: int):
        self._database_id = value

    @route_id.setter
    def route_id(self, value: int):
        self._route_id = value

    @navigation_direction.setter
    def navigation_direction(self, value: int):
        self._navigation_direction = value

    @supplementary_data.setter
    def supplementary_data(self, value: int):
        self._supplementary_data = value

    @route_name.setter
    def route_name(self, value: str):
        self._route_name = value

    def add_Wp_Definitions(self, item: Wp_DefinitionsClass):
        if self._WP_definitions is None:
            self._WP_definitions = []
            self.nb_items = 0
        self._WP_definitions.append(item)
        self.nb_items += 1

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._start_waypoint_id = val[0]
        self._nb_items = check_valid(val[1], 65535, 0)
        self._database_id = val[2]
        self._route_id = val[3]
        self._navigation_direction = val[4] & 0x7
        self._supplementary_data = (val[4] >> 3) & 0x3
        start_byte += 9
        dec_str, dec_str_len = extract_var_str(payload, start_byte)
        self._route_name = dec_str
        start_byte += dec_str_len
        val = self._struct_str_1.unpack_from(payload, start_byte)
        start_byte += 1
        for i in range(0, self.nb_items):
            dec_obj, start_byte = self.Wp_DefinitionsClass().decode_payload(payload, start_byte)
            self._WP_definitions.append(dec_obj)

        return self, start_byte

    def encode_payload(self) -> bytearray:
        buf_size = self.DEFAULT_BUFFER_SIZE
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._navigation_direction & 0x7) << 0
        v0 |= (self._supplementary_data & 0x3) << 3
        v0 |= 0x7 << 5
        self._struct_str_0.pack_into(buffer, start_byte, self._start_waypoint_id, self._nb_items, self._database_id, self._route_id, v0)
        start_byte += 9
        inserted_len = insert_var_str(buffer, start_byte, self._route_name)
        start_byte += inserted_len
        v0 = 0xff
        self._struct_str_1.pack_into(buffer, start_byte, v0)
        start_byte += 1
        for repeat_field in self._WP_definitions:
            start_byte = repeat_field.encode_payload(buffer, start_byte)

        return buffer[:start_byte]

    def from_protobuf(self, message: Pgn129285ClassPb):
        self._start_waypoint_id = message.start_waypoint_id
        self._nb_items = message.nb_items
        self._database_id = message.database_id
        self._route_id = message.route_id
        self._navigation_direction = message.navigation_direction
        self._supplementary_data = message.supplementary_data
        self._route_name = message.route_name
        for sub_set in message.WP_definitions:
            self._WP_definitions.append(self.Wp_DefinitionsClass(protobuf=sub_set))
        self.nb_items = len(self._WP_definitions)

    def as_protobuf(self) -> Pgn129285ClassPb:
        message = Pgn129285ClassPb()
        message.start_waypoint_id = self._start_waypoint_id
        message.nb_items = self._nb_items
        message.database_id = self._database_id
        message.route_id = self._route_id
        message.navigation_direction = self._navigation_direction
        message.supplementary_data = self._supplementary_data
        message.route_name = self._route_name
        for sub_set in self._WP_definitions:
            message.WP_definitions.append(sub_set.as_protobuf())
        self.nb_items = len(self._WP_definitions)
        return message

    def set_protobuf(self, message: Pgn129285ClassPb):
        message.start_waypoint_id = self._start_waypoint_id
        message.nb_items = self._nb_items
        message.database_id = self._database_id
        message.route_id = self._route_id
        message.navigation_direction = self._navigation_direction
        message.supplementary_data = self._supplementary_data
        message.route_name = self._route_name
        for sub_set in self._WP_definitions:
            message.WP_definitions.append(sub_set.as_protobuf())
        self.nb_items = len(self._WP_definitions)

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129285ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [start_waypoint_id={self._start_waypoint_id}, nb_items={self._nb_items}, database_id={self._database_id}, route_id={self._route_id}, navigation_direction={self._navigation_direction}, supplementary_data={self._supplementary_data}, route_name={self._route_name}, WP_definitions={self._WP_definitions}]'


class Pgn129539Class(NMEA2000DecodedMsg):

    _pgn = 129539
    _name = 'GNSS DOPs'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129539ClassPb

    _struct_str_0 = struct.Struct('<BBhhh')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_desired_mode', '_actual_mode', '_HDOP', '_VDOP', '_TDOP')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _desired_mode_enum = {
        0: '1D',
        1: '2D',
        2: '3D',
        3: 'Auto',
        4: 'Reserved',
        5: 'Reserved',
        6: 'Error',
        7: 'Unknown'
        }
    _actual_mode_enum = {
        0: '1D',
        1: '2D',
        2: '3D',
        3: 'Auto',
        4: 'Reserved',
        5: 'Reserved',
        6: 'Error',
        7: 'Unknown'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        EnumFormatter('_desired_mode', 'Desired Mode', 0x7, local = _desired_mode_enum ),
        EnumFormatter('_actual_mode', 'Actual Mode', 0x7, local = _actual_mode_enum ),
        FloatFormatter('_HDOP', 'HDOP', '{:.0f}'),
        FloatFormatter('_VDOP', 'VDOP', '{:.0f}'),
        FloatFormatter('_TDOP', 'TDOP', '{:.0f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def desired_mode(self) -> int:
        return self._desired_mode

    @property
    def actual_mode(self) -> int:
        return self._actual_mode

    @property
    def HDOP(self) -> float:
        return self._HDOP

    @property
    def VDOP(self) -> float:
        return self._VDOP

    @property
    def TDOP(self) -> float:
        return self._TDOP

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @desired_mode.setter
    def desired_mode(self, value: int):
        self._desired_mode = value

    @actual_mode.setter
    def actual_mode(self, value: int):
        self._actual_mode = value

    @HDOP.setter
    def HDOP(self, value: float):
        self._HDOP = value

    @VDOP.setter
    def VDOP(self, value: float):
        self._VDOP = value

    @TDOP.setter
    def TDOP(self, value: float):
        self._TDOP = value

    @property
    def desired_mode_text(self) -> str:
        return self._desired_mode_enum.get(self._desired_mode, 'desired_mode key error')

    @property
    def actual_mode_text(self) -> str:
        return self._actual_mode_enum.get(self._actual_mode, 'actual_mode key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._desired_mode = val[1] & 0x7
        self._actual_mode = (val[1] >> 5) & 0x7
        self._HDOP = check_convert_float(val[2], 0x7fff, 0.01)
        self._VDOP = check_convert_float(val[3], 0x7fff, 0.01)
        self._TDOP = check_convert_float(val[4], 0x7fff, 0.01)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._desired_mode & 0x7) << 0
        v0 |= 0x3 << 3
        v0 |= (self._actual_mode & 0x7) << 5
        v1 = convert_to_int(self._HDOP, 0x7fff, 0.01)
        v2 = convert_to_int(self._VDOP, 0x7fff, 0.01)
        v3 = convert_to_int(self._TDOP, 0x7fff, 0.01)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn129539ClassPb):
        self._sequence_id = message.sequence_id
        self._desired_mode = message.desired_mode
        self._actual_mode = message.actual_mode
        self._HDOP = message.HDOP
        self._VDOP = message.VDOP
        self._TDOP = message.TDOP

    def as_protobuf(self) -> Pgn129539ClassPb:
        message = Pgn129539ClassPb()
        message.sequence_id = self._sequence_id
        message.desired_mode = self._desired_mode
        message.actual_mode = self._actual_mode
        message.HDOP = self._HDOP
        message.VDOP = self._VDOP
        message.TDOP = self._TDOP
        return message

    def set_protobuf(self, message: Pgn129539ClassPb):
        message.sequence_id = self._sequence_id
        message.desired_mode = self._desired_mode
        message.actual_mode = self._actual_mode
        message.HDOP = self._HDOP
        message.VDOP = self._VDOP
        message.TDOP = self._TDOP

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129539ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, desired_mode={self._desired_mode}, actual_mode={self._actual_mode}, HDOP={self._HDOP}, VDOP={self._VDOP}, TDOP={self._TDOP}]'


class Pgn129540Class(NMEA2000DecodedMsg):

    class Satellites_DataClass:

        _struct_str_0 = struct.Struct('<BhHHiB')
        _struct_str_0_size = _struct_str_0.size
        __slots__ = ('_satellite_number', '_elevation', '_azimuth', '_signal_noise_ratio', '_range_residuals', '_status')

        _static_size = 12

        @classmethod
        def size(cls):
            return cls._static_size

        @staticmethod
        def variable_size() -> bool:
            return False


        _status_enum = {
            0: 'Not tracked',
            1: 'Tracked',
            2: 'Used',
            3: 'Not tracked+Diff',
            4: 'Tracked+Diff',
            5: 'Used+Diff'
            }

        _json_format = (
            GenericFormatter('_satellite_number', 'PRN', 0xff),
            FloatFormatter('_elevation', 'Elevation', '{:.4f}'),
            FloatFormatter('_azimuth', 'Azimuth', '{:.4f}'),
            FloatFormatter('_signal_noise_ratio', 'SNR', '{:.0f}'),
            GenericFormatter('_range_residuals', 'Range residuals', 0x7fffffff),
            EnumFormatter('_status', 'Status', 0xf, local = _status_enum )
            )

        def json_format(self):
            return self._json_format

        def __init__(self, protobuf=None):
            if protobuf is not None:
                self.from_protobuf(protobuf)

        @property
        def satellite_number(self) -> int:
            return self._satellite_number

        @property
        def elevation(self) -> float:
            return self._elevation

        @property
        def azimuth(self) -> float:
            return self._azimuth

        @property
        def signal_noise_ratio(self) -> float:
            return self._signal_noise_ratio

        @property
        def range_residuals(self) -> int:
            return self._range_residuals

        @property
        def status(self) -> int:
            return self._status

        @satellite_number.setter
        def satellite_number(self, value: int):
            self._satellite_number = value

        @elevation.setter
        def elevation(self, value: float):
            self._elevation = value

        @azimuth.setter
        def azimuth(self, value: float):
            self._azimuth = value

        @signal_noise_ratio.setter
        def signal_noise_ratio(self, value: float):
            self._signal_noise_ratio = value

        @range_residuals.setter
        def range_residuals(self, value: int):
            self._range_residuals = value

        @status.setter
        def status(self, value: int):
            self._status = value

        @property
        def status_text(self) -> str:
            return self._status_enum.get(self._status, 'status key error')

        def decode_payload(self, payload, start_byte=0):
            val = self._struct_str_0.unpack_from(payload, start_byte)
            self._satellite_number = val[0]
            self._elevation = check_convert_float(val[1], 0x7fff, 0.0001)
            self._azimuth = check_convert_float(val[2], 0xffff, 0.0001)
            self._signal_noise_ratio = check_convert_float(val[3], 0xffff, 0.01)
            self._range_residuals = val[4]
            self._status = val[5] & 0xF
            start_byte += 12
            return self

        def encode_payload(self, buffer, start_byte):
            v0 = convert_to_int(self._elevation, 0x7fff, 0.0001)
            v1 = convert_to_int(self._azimuth, 0xffff, 0.0001)
            v2 = convert_to_int(self._signal_noise_ratio, 0xffff, 0.01)
            v3 = (self._status & 0xf) << 0
            v3 |= 0xf << 4
            self._struct_str_0.pack_into(buffer, 0 + start_byte, self._satellite_number, v0, v1, v2, self._range_residuals, v3)
            return self._static_size + start_byte

        def from_protobuf(self, message: Pgn129540ClassPb.Satellites_DataClassPb):
            self._satellite_number = message.satellite_number
            self._elevation = message.elevation
            self._azimuth = message.azimuth
            self._signal_noise_ratio = message.signal_noise_ratio
            self._range_residuals = message.range_residuals
            self._status = message.status

        def as_protobuf(self) -> Pgn129540ClassPb.Satellites_DataClassPb:
            message = Pgn129540ClassPb.Satellites_DataClassPb()
            message.satellite_number = self._satellite_number
            message.elevation = self._elevation
            message.azimuth = self._azimuth
            message.signal_noise_ratio = self._signal_noise_ratio
            message.range_residuals = self._range_residuals
            message.status = self._status
            return message

        def set_protobuf(self, message: Pgn129540ClassPb.Satellites_DataClassPb):
            message.satellite_number = self._satellite_number
            message.elevation = self._elevation
            message.azimuth = self._azimuth
            message.signal_noise_ratio = self._signal_noise_ratio
            message.range_residuals = self._range_residuals
            message.status = self._status

        def __str__(self):
            return f'(Satellites_DataClass) [satellite_number={self._satellite_number}, elevation={self._elevation}, azimuth={self._azimuth}, signal_noise_ratio={self._signal_noise_ratio}, range_residuals={self._range_residuals}, status={self._status}]'


    _pgn = 129540
    _name = 'GNSS Sats in View'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129540ClassPb

    _struct_str_0 = struct.Struct('<BBB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_mode', '_sats_in_view', '_satellites_data')


    @staticmethod
    def variable_size() -> bool:
        return True

    _mode_enum = {
        3: 'Range residuals used to calculate position'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        EnumFormatter('_mode', 'Mode', 0x3, local = _mode_enum ),
        RepeatedFormatter('_sats_in_view', 'Sats in View', '_satellites_data'),
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        self._sats_in_view = 0
        self._satellites_data = []
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def mode(self) -> int:
        return self._mode

    @property
    def sats_in_view(self) -> int:
        return self._sats_in_view

    @property
    def satellites_data(self) -> list:
        return self._satellites_data

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @mode.setter
    def mode(self, value: int):
        self._mode = value

    @sats_in_view.setter
    def sats_in_view(self, value: int):
        self._sats_in_view = value

    @property
    def mode_text(self) -> str:
        return self._mode_enum.get(self._mode, 'mode key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._mode = val[1] & 0x3
        self._sats_in_view = check_valid(val[2], 255, 0)
        start_byte += 3
        for i in range(0, self.sats_in_view):
            self._satellites_data.append(self.Satellites_DataClass().decode_payload(payload, start_byte))
            start_byte += self.Satellites_DataClass.size()

        return self, start_byte

    def encode_payload(self) -> bytearray:
        buf_size = self.DEFAULT_BUFFER_SIZE
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._mode & 0x3) << 0
        v0 |= 0x3f << 2
        self._struct_str_0.pack_into(buffer, start_byte, self._sequence_id, v0, self._sats_in_view)
        start_byte += 3
        for repeat_field in self._satellites_data:
            start_byte = repeat_field.encode_payload(buffer, start_byte)

        return buffer[:start_byte]

    def from_protobuf(self, message: Pgn129540ClassPb):
        self._sequence_id = message.sequence_id
        self._mode = message.mode
        self._sats_in_view = message.sats_in_view
        for sub_set in message.satellites_data:
            self._satellites_data.append(self.Satellites_DataClass(protobuf=sub_set))
        self.sats_in_view = len(self._satellites_data)

    def as_protobuf(self) -> Pgn129540ClassPb:
        message = Pgn129540ClassPb()
        message.sequence_id = self._sequence_id
        message.mode = self._mode
        message.sats_in_view = self._sats_in_view
        for sub_set in self._satellites_data:
            message.satellites_data.append(sub_set.as_protobuf())
        self.sats_in_view = len(self._satellites_data)
        return message

    def set_protobuf(self, message: Pgn129540ClassPb):
        message.sequence_id = self._sequence_id
        message.mode = self._mode
        message.sats_in_view = self._sats_in_view
        for sub_set in self._satellites_data:
            message.satellites_data.append(sub_set.as_protobuf())
        self.sats_in_view = len(self._satellites_data)

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129540ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, mode={self._mode}, sats_in_view={self._sats_in_view}, satellites_data={self._satellites_data}]'


class Pgn129794Class(NMEA2000DecodedMsg):

    _pgn = 129794
    _name = 'AIS Class A Static and Voyage Related Data'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129794ClassPb

    _struct_str_0 = struct.Struct('<Bii')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<BHHHHHIh')
    _struct_str_1_size = _struct_str_1.size
    _struct_str_2 = struct.Struct('<BB')
    _struct_str_2_size = _struct_str_2.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_IMO_number', '_callsign', '_ship_name', '_type_of_ship', '_length', '_beam', '_position_from_starboard', '_position_from_bow', '_ETA_date', '_ETA_time', '_draft', '_destination', '_AIS_version', '_GNSS_type', '_DTE', '_AIS_transceiver_info')

    _static_size = 75

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = 'AIS Repeat Indicator'
    _type_of_ship_enum = 'Type of ship'
    _AIS_version_enum = {
        0: 'ITU-R M.1371-1',
        1: 'ITU-R M.1371-3'
        }
    _GNSS_type_enum = 'GNSS type'
    _DTE_enum = {
        0: 'available',
        1: 'not available'
        }
    _AIS_transceiver_info_enum = 'AIS Transceiver information'
    _json_format = (
        GenericFormatter('_message_id', 'Message ID', 0x3f),
        EnumFormatter('_repeat_indicator', 'Repeat indicator', 0x3, global_enum ='AIS Repeat Indicator' ),
        GenericFormatter('_mmsi', 'User ID', 0x7fffffff),
        GenericFormatter('_IMO_number', 'IMO number', 0x7fffffff),
        TextFormatter('_callsign', 'Callsign'),
        TextFormatter('_ship_name', 'Name'),
        EnumFormatter('_type_of_ship', 'Type of ship', 0xff, global_enum ='Type of ship' ),
        FloatFormatter('_length', 'Length', '{:.1f}'),
        FloatFormatter('_beam', 'Beam', '{:.1f}'),
        FloatFormatter('_position_from_starboard', 'Position reference from Starboard', '{:.1f}'),
        FloatFormatter('_position_from_bow', 'Position reference from Bow', '{:.1f}'),
        GenericFormatter('_ETA_date', 'ETA Date', 0xffff),
        FloatFormatter('_ETA_time', 'ETA Time', '{:.2f}'),
        FloatFormatter('_draft', 'Draft', '{:.1f}'),
        TextFormatter('_destination', 'Destination'),
        EnumFormatter('_AIS_version', 'AIS version indicator', 0x3, local = _AIS_version_enum ),
        EnumFormatter('_GNSS_type', 'GNSS type', 0xf, global_enum ='GNSS type' ),
        EnumFormatter('_DTE', 'DTE', 0x1, local = _DTE_enum ),
        EnumFormatter('_AIS_transceiver_info', 'AIS Transceiver information', 0x1f, global_enum ='AIS Transceiver information' )
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def IMO_number(self) -> int:
        return self._IMO_number

    @property
    def callsign(self) -> str:
        return self._callsign

    @property
    def ship_name(self) -> str:
        return self._ship_name

    @property
    def type_of_ship(self) -> int:
        return self._type_of_ship

    @property
    def length(self) -> float:
        return self._length

    @property
    def beam(self) -> float:
        return self._beam

    @property
    def position_from_starboard(self) -> float:
        return self._position_from_starboard

    @property
    def position_from_bow(self) -> float:
        return self._position_from_bow

    @property
    def ETA_date(self) -> int:
        return self._ETA_date

    @property
    def ETA_time(self) -> float:
        return self._ETA_time

    @property
    def draft(self) -> float:
        return self._draft

    @property
    def destination(self) -> str:
        return self._destination

    @property
    def AIS_version(self) -> int:
        return self._AIS_version

    @property
    def GNSS_type(self) -> int:
        return self._GNSS_type

    @property
    def DTE(self) -> int:
        return self._DTE

    @property
    def AIS_transceiver_info(self) -> int:
        return self._AIS_transceiver_info

    @message_id.setter
    def message_id(self, value: int):
        self._message_id = value

    @repeat_indicator.setter
    def repeat_indicator(self, value: int):
        self._repeat_indicator = value

    @mmsi.setter
    def mmsi(self, value: int):
        self._mmsi = value

    @IMO_number.setter
    def IMO_number(self, value: int):
        self._IMO_number = value

    @callsign.setter
    def callsign(self, value: str):
        self._callsign = value

    @ship_name.setter
    def ship_name(self, value: str):
        self._ship_name = value

    @type_of_ship.setter
    def type_of_ship(self, value: int):
        self._type_of_ship = value

    @length.setter
    def length(self, value: float):
        self._length = value

    @beam.setter
    def beam(self, value: float):
        self._beam = value

    @position_from_starboard.setter
    def position_from_starboard(self, value: float):
        self._position_from_starboard = value

    @position_from_bow.setter
    def position_from_bow(self, value: float):
        self._position_from_bow = value

    @ETA_date.setter
    def ETA_date(self, value: int):
        self._ETA_date = value

    @ETA_time.setter
    def ETA_time(self, value: float):
        self._ETA_time = value

    @draft.setter
    def draft(self, value: float):
        self._draft = value

    @destination.setter
    def destination(self, value: str):
        self._destination = value

    @AIS_version.setter
    def AIS_version(self, value: int):
        self._AIS_version = value

    @GNSS_type.setter
    def GNSS_type(self, value: int):
        self._GNSS_type = value

    @DTE.setter
    def DTE(self, value: int):
        self._DTE = value

    @AIS_transceiver_info.setter
    def AIS_transceiver_info(self, value: int):
        self._AIS_transceiver_info = value

    @property
    def repeat_indicator_text(self) -> str:
        return resolve_global_enum(self._repeat_indicator_enum, self._repeat_indicator)

    @property
    def type_of_ship_text(self) -> str:
        return resolve_global_enum(self._type_of_ship_enum, self._type_of_ship)

    @property
    def AIS_version_text(self) -> str:
        return self._AIS_version_enum.get(self._AIS_version, 'AIS_version key error')

    @property
    def GNSS_type_text(self) -> str:
        return resolve_global_enum(self._GNSS_type_enum, self._GNSS_type)

    @property
    def DTE_text(self) -> str:
        return self._DTE_enum.get(self._DTE, 'DTE key error')

    @property
    def AIS_transceiver_info_text(self) -> str:
        return resolve_global_enum(self._AIS_transceiver_info_enum, self._AIS_transceiver_info)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._IMO_number = val[2]
        start_byte += 9
        self._callsign = clean_string(payload[start_byte: start_byte + 7])
        start_byte += 7
        self._ship_name = clean_string(payload[start_byte: start_byte + 20])
        start_byte += 20
        val = self._struct_str_1.unpack_from(payload, start_byte)
        self._type_of_ship = val[0]
        self._length = check_convert_float(val[1], 0xffff, 0.1)
        self._beam = check_convert_float(val[2], 0xffff, 0.1)
        self._position_from_starboard = check_convert_float(val[3], 0xffff, 0.1)
        self._position_from_bow = check_convert_float(val[4], 0xffff, 0.1)
        self._ETA_date = val[5]
        self._ETA_time = check_convert_float(val[6], 0xffffffff, 0.0001)
        self._draft = check_convert_float(val[7], 0x7fff, 0.01)
        start_byte += 17
        self._destination = clean_string(payload[start_byte: start_byte + 20])
        start_byte += 20
        val = self._struct_str_2.unpack_from(payload, start_byte)
        self._AIS_version = val[0] & 0x3
        self._GNSS_type = (val[0] >> 2) & 0xF
        self._DTE = (val[0] >> 6) & 0x1
        self._AIS_transceiver_info = val[1] & 0x1F
        start_byte += 2
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi, self._IMO_number)
        insert_string(buffer, 9 + start_byte, 7, self._callsign)
        insert_string(buffer, 16 + start_byte, 20, self._ship_name)
        v0 = convert_to_int(self._length, 0xffff, 0.1)
        v1 = convert_to_int(self._beam, 0xffff, 0.1)
        v2 = convert_to_int(self._position_from_starboard, 0xffff, 0.1)
        v3 = convert_to_int(self._position_from_bow, 0xffff, 0.1)
        v4 = convert_to_int(self._ETA_time, 0xffffffff, 0.0001)
        v5 = convert_to_int(self._draft, 0x7fff, 0.01)
        self._struct_str_1.pack_into(buffer, 36 + start_byte, self._type_of_ship, v0, v1, v2, v3, self._ETA_date, v4, v5)
        insert_string(buffer, 53 + start_byte, 20, self._destination)
        v0 = (self._AIS_version & 0x3) << 0
        v0 |= (self._GNSS_type & 0xf) << 2
        v0 |= (self._DTE & 0x1) << 6
        v0 |= 0x1 << 7
        v1 = (self._AIS_transceiver_info & 0x1f) << 0
        self._struct_str_2.pack_into(buffer, 73 + start_byte, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn129794ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._IMO_number = message.IMO_number
        self._callsign = message.callsign
        self._ship_name = message.ship_name
        self._type_of_ship = message.type_of_ship
        self._length = message.length
        self._beam = message.beam
        self._position_from_starboard = message.position_from_starboard
        self._position_from_bow = message.position_from_bow
        self._ETA_date = message.ETA_date
        self._ETA_time = message.ETA_time
        self._draft = message.draft
        self._destination = message.destination
        self._AIS_version = message.AIS_version
        self._GNSS_type = message.GNSS_type
        self._DTE = message.DTE
        self._AIS_transceiver_info = message.AIS_transceiver_info

    def as_protobuf(self) -> Pgn129794ClassPb:
        message = Pgn129794ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.IMO_number = self._IMO_number
        message.callsign = self._callsign
        message.ship_name = self._ship_name
        message.type_of_ship = self._type_of_ship
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard
        message.position_from_bow = self._position_from_bow
        message.ETA_date = self._ETA_date
        message.ETA_time = self._ETA_time
        message.draft = self._draft
        message.destination = self._destination
        message.AIS_version = self._AIS_version
        message.GNSS_type = self._GNSS_type
        message.DTE = self._DTE
        message.AIS_transceiver_info = self._AIS_transceiver_info
        return message

    def set_protobuf(self, message: Pgn129794ClassPb):
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.IMO_number = self._IMO_number
        message.callsign = self._callsign
        message.ship_name = self._ship_name
        message.type_of_ship = self._type_of_ship
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard
        message.position_from_bow = self._position_from_bow
        message.ETA_date = self._ETA_date
        message.ETA_time = self._ETA_time
        message.draft = self._draft
        message.destination = self._destination
        message.AIS_version = self._AIS_version
        message.GNSS_type = self._GNSS_type
        message.DTE = self._DTE
        message.AIS_transceiver_info = self._AIS_transceiver_info

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129794ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, IMO_number={self._IMO_number}, callsign={self._callsign}, ship_name={self._ship_name}, type_of_ship={self._type_of_ship}, length={self._length}, beam={self._beam}, position_from_starboard={self._position_from_starboard}, position_from_bow={self._position_from_bow}, ETA_date={self._ETA_date}, ETA_time={self._ETA_time}, draft={self._draft}, destination={self._destination}, AIS_version={self._AIS_version}, GNSS_type={self._GNSS_type}, DTE={self._DTE}, AIS_transceiver_info={self._AIS_transceiver_info}]'


class Pgn129809Class(NMEA2000DecodedMsg):

    _pgn = 129809
    _name = 'AIS Class B static data (msg 24 Part A)'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129809ClassPb

    _struct_str_0 = struct.Struct('<Bi')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_ship_name')

    _static_size = 25

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = 'AIS Repeat Indicator'
    _json_format = (
        GenericFormatter('_message_id', 'Message ID', 0x3f),
        EnumFormatter('_repeat_indicator', 'Repeat indicator', 0x3, global_enum ='AIS Repeat Indicator' ),
        GenericFormatter('_mmsi', 'User ID', 0x7fffffff),
        TextFormatter('_ship_name', 'Name')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def ship_name(self) -> str:
        return self._ship_name

    @message_id.setter
    def message_id(self, value: int):
        self._message_id = value

    @repeat_indicator.setter
    def repeat_indicator(self, value: int):
        self._repeat_indicator = value

    @mmsi.setter
    def mmsi(self, value: int):
        self._mmsi = value

    @ship_name.setter
    def ship_name(self, value: str):
        self._ship_name = value

    @property
    def repeat_indicator_text(self) -> str:
        return resolve_global_enum(self._repeat_indicator_enum, self._repeat_indicator)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        start_byte += 5
        self._ship_name = clean_string(payload[start_byte: start_byte + 20])
        start_byte += 20
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi)
        insert_string(buffer, 5 + start_byte, 20, self._ship_name)
        return buffer

    def from_protobuf(self, message: Pgn129809ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._ship_name = message.ship_name

    def as_protobuf(self) -> Pgn129809ClassPb:
        message = Pgn129809ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.ship_name = self._ship_name
        return message

    def set_protobuf(self, message: Pgn129809ClassPb):
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.ship_name = self._ship_name

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129809ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, ship_name={self._ship_name}]'


class Pgn129810Class(NMEA2000DecodedMsg):

    _pgn = 129810
    _name = 'AIS Class B static data (msg 24 Part B)'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn129810ClassPb

    _struct_str_0 = struct.Struct('<BiB')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<HHHHiB')
    _struct_str_1_size = _struct_str_1.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_type_of_ship', '_vendor_id', '_call_sign', '_length', '_beam', '_position_from_starboard', '_position_from_bow', '_mothership_mmsi')

    _static_size = 33

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = 'AIS Repeat Indicator'
    _type_of_ship_enum = 'Type of ship'
    _json_format = (
        GenericFormatter('_message_id', 'Message ID', 0x3f),
        EnumFormatter('_repeat_indicator', 'Repeat indicator', 0x3, global_enum ='AIS Repeat Indicator' ),
        GenericFormatter('_mmsi', 'User ID', 0x7fffffff),
        EnumFormatter('_type_of_ship', 'Type of ship', 0xff, global_enum ='Type of ship' ),
        TextFormatter('_vendor_id', 'Vendor ID'),
        TextFormatter('_call_sign', 'Callsign'),
        FloatFormatter('_length', 'Length', '{:.1f}'),
        FloatFormatter('_beam', 'Beam', '{:.1f}'),
        FloatFormatter('_position_from_starboard', 'Position reference from Starboard', '{:.1f}'),
        FloatFormatter('_position_from_bow', 'Position reference from Bow', '{:.1f}'),
        GenericFormatter('_mothership_mmsi', 'Mothership User ID', 0x7fffffff)
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def type_of_ship(self) -> int:
        return self._type_of_ship

    @property
    def vendor_id(self) -> str:
        return self._vendor_id

    @property
    def call_sign(self) -> str:
        return self._call_sign

    @property
    def length(self) -> float:
        return self._length

    @property
    def beam(self) -> float:
        return self._beam

    @property
    def position_from_starboard(self) -> float:
        return self._position_from_starboard

    @property
    def position_from_bow(self) -> float:
        return self._position_from_bow

    @property
    def mothership_mmsi(self) -> int:
        return self._mothership_mmsi

    @message_id.setter
    def message_id(self, value: int):
        self._message_id = value

    @repeat_indicator.setter
    def repeat_indicator(self, value: int):
        self._repeat_indicator = value

    @mmsi.setter
    def mmsi(self, value: int):
        self._mmsi = value

    @type_of_ship.setter
    def type_of_ship(self, value: int):
        self._type_of_ship = value

    @vendor_id.setter
    def vendor_id(self, value: str):
        self._vendor_id = value

    @call_sign.setter
    def call_sign(self, value: str):
        self._call_sign = value

    @length.setter
    def length(self, value: float):
        self._length = value

    @beam.setter
    def beam(self, value: float):
        self._beam = value

    @position_from_starboard.setter
    def position_from_starboard(self, value: float):
        self._position_from_starboard = value

    @position_from_bow.setter
    def position_from_bow(self, value: float):
        self._position_from_bow = value

    @mothership_mmsi.setter
    def mothership_mmsi(self, value: int):
        self._mothership_mmsi = value

    @property
    def repeat_indicator_text(self) -> str:
        return resolve_global_enum(self._repeat_indicator_enum, self._repeat_indicator)

    @property
    def type_of_ship_text(self) -> str:
        return resolve_global_enum(self._type_of_ship_enum, self._type_of_ship)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._type_of_ship = val[2]
        start_byte += 6
        self._vendor_id = clean_string(payload[start_byte: start_byte + 7])
        start_byte += 7
        self._call_sign = clean_string(payload[start_byte: start_byte + 7])
        start_byte += 7
        val = self._struct_str_1.unpack_from(payload, start_byte)
        self._length = check_convert_float(val[0], 0xffff, 0.1)
        self._beam = check_convert_float(val[1], 0xffff, 0.1)
        self._position_from_starboard = check_convert_float(val[2], 0xffff, 0.1)
        self._position_from_bow = check_convert_float(val[3], 0xffff, 0.1)
        self._mothership_mmsi = val[4]
        start_byte += 13
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi, self._type_of_ship)
        insert_string(buffer, 6 + start_byte, 7, self._vendor_id)
        insert_string(buffer, 13 + start_byte, 7, self._call_sign)
        v0 = convert_to_int(self._length, 0xffff, 0.1)
        v1 = convert_to_int(self._beam, 0xffff, 0.1)
        v2 = convert_to_int(self._position_from_starboard, 0xffff, 0.1)
        v3 = convert_to_int(self._position_from_bow, 0xffff, 0.1)
        v4 = 0x3 << 0
        v4 |= 0x3f << 2
        self._struct_str_1.pack_into(buffer, 20 + start_byte, v0, v1, v2, v3, self._mothership_mmsi, v4)
        return buffer

    def from_protobuf(self, message: Pgn129810ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._type_of_ship = message.type_of_ship
        self._vendor_id = message.vendor_id
        self._call_sign = message.call_sign
        self._length = message.length
        self._beam = message.beam
        self._position_from_starboard = message.position_from_starboard
        self._position_from_bow = message.position_from_bow
        self._mothership_mmsi = message.mothership_mmsi

    def as_protobuf(self) -> Pgn129810ClassPb:
        message = Pgn129810ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.type_of_ship = self._type_of_ship
        message.vendor_id = self._vendor_id
        message.call_sign = self._call_sign
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard
        message.position_from_bow = self._position_from_bow
        message.mothership_mmsi = self._mothership_mmsi
        return message

    def set_protobuf(self, message: Pgn129810ClassPb):
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.type_of_ship = self._type_of_ship
        message.vendor_id = self._vendor_id
        message.call_sign = self._call_sign
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard
        message.position_from_bow = self._position_from_bow
        message.mothership_mmsi = self._mothership_mmsi

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129810ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, type_of_ship={self._type_of_ship}, vendor_id={self._vendor_id}, call_sign={self._call_sign}, length={self._length}, beam={self._beam}, position_from_starboard={self._position_from_starboard}, position_from_bow={self._position_from_bow}, mothership_mmsi={self._mothership_mmsi}]'


class Pgn130074Class(NMEA2000DecodedMsg):

    class Wp_DefinitionsClass:

        _struct_str_0 = struct.Struct('<H')
        _struct_str_0_size = _struct_str_0.size
        _struct_str_1 = struct.Struct('<ii')
        _struct_str_1_size = _struct_str_1.size
        __slots__ = ('_waypoint_id', '_waypoint_name', '_waypoint_latitude', '_waypoint_longitude')


        @staticmethod
        def variable_size() -> bool:
            return True



        _json_format = (
            GenericFormatter('_waypoint_id', 'WP ID', 0xffff),
            TextFormatter('_waypoint_name', 'WP Name'),
            FloatFormatter('_waypoint_latitude', 'WP Latitude', '{:.6f}'),
            FloatFormatter('_waypoint_longitude', 'WP Longitude', '{:.6f}')
            )

        def json_format(self):
            return self._json_format

        def __init__(self, protobuf=None):
            if protobuf is not None:
                self.from_protobuf(protobuf)

        @property
        def waypoint_id(self) -> int:
            return self._waypoint_id

        @property
        def waypoint_name(self) -> str:
            return self._waypoint_name

        @property
        def waypoint_latitude(self) -> float:
            return self._waypoint_latitude

        @property
        def waypoint_longitude(self) -> float:
            return self._waypoint_longitude

        @waypoint_id.setter
        def waypoint_id(self, value: int):
            self._waypoint_id = value

        @waypoint_name.setter
        def waypoint_name(self, value: str):
            self._waypoint_name = value

        @waypoint_latitude.setter
        def waypoint_latitude(self, value: float):
            self._waypoint_latitude = value

        @waypoint_longitude.setter
        def waypoint_longitude(self, value: float):
            self._waypoint_longitude = value

        def decode_payload(self, payload, start_byte=0):
            val = self._struct_str_0.unpack_from(payload, start_byte)
            self._waypoint_id = val[0]
            start_byte += 2
            dec_str, dec_str_len = extract_var_str(payload, start_byte)
            self._waypoint_name = dec_str
            start_byte += dec_str_len
            val = self._struct_str_1.unpack_from(payload, start_byte)
            self._waypoint_latitude = check_convert_float(val[0], 0x7fffffff, 1e-07)
            self._waypoint_longitude = check_convert_float(val[1], 0x7fffffff, 1e-07)
            start_byte += 8
            return self, start_byte

        def encode_payload(self, buffer, start_byte):
            self._struct_str_0.pack_into(buffer, start_byte, self._waypoint_id)
            start_byte += 2
            inserted_len = insert_var_str(buffer, start_byte, self._waypoint_name)
            start_byte += inserted_len
            v0 = convert_to_int(self._waypoint_latitude, 0x7fffffff, 1e-07)
            v1 = convert_to_int(self._waypoint_longitude, 0x7fffffff, 1e-07)
            self._struct_str_1.pack_into(buffer, start_byte, v0, v1)
            start_byte += 8
            return start_byte

        def from_protobuf(self, message: Pgn130074ClassPb.Wp_DefinitionsClassPb):
            self._waypoint_id = message.waypoint_id
            self._waypoint_name = message.waypoint_name
            self._waypoint_latitude = message.waypoint_latitude
            self._waypoint_longitude = message.waypoint_longitude

        def as_protobuf(self) -> Pgn130074ClassPb.Wp_DefinitionsClassPb:
            message = Pgn130074ClassPb.Wp_DefinitionsClassPb()
            message.waypoint_id = self._waypoint_id
            message.waypoint_name = self._waypoint_name
            message.waypoint_latitude = self._waypoint_latitude
            message.waypoint_longitude = self._waypoint_longitude
            return message

        def set_protobuf(self, message: Pgn130074ClassPb.Wp_DefinitionsClassPb):
            message.waypoint_id = self._waypoint_id
            message.waypoint_name = self._waypoint_name
            message.waypoint_latitude = self._waypoint_latitude
            message.waypoint_longitude = self._waypoint_longitude

        def __str__(self):
            return f'(Wp_DefinitionsClass) [waypoint_id={self._waypoint_id}, waypoint_name={self._waypoint_name}, waypoint_latitude={self._waypoint_latitude}, waypoint_longitude={self._waypoint_longitude}]'


    _pgn = 130074
    _name = 'Route and WP Service - WP List - WP Name & Position'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn130074ClassPb

    _struct_str_0 = struct.Struct('<HHHHH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_start_wp_id', '_nb_items', '_nb_valid_wp', '_database_id', '_WP_definitions')


    @staticmethod
    def variable_size() -> bool:
        return True

    _json_format = (
        GenericFormatter('_start_wp_id', 'Start WP ID', 0xffff),
        RepeatedFormatter('_nb_items', 'nItems', '_WP_definitions'),
        GenericFormatter('_nb_valid_wp', 'Number of valid WPs in the WP-List', 0xffff),
        GenericFormatter('_database_id', 'Database ID', 0xffff),
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        self._nb_items = 0
        self._WP_definitions = []
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def start_wp_id(self) -> int:
        return self._start_wp_id

    @property
    def nb_items(self) -> int:
        return self._nb_items

    @property
    def nb_valid_wp(self) -> int:
        return self._nb_valid_wp

    @property
    def database_id(self) -> int:
        return self._database_id

    @property
    def WP_definitions(self) -> list:
        return self._WP_definitions

    @start_wp_id.setter
    def start_wp_id(self, value: int):
        self._start_wp_id = value

    @nb_items.setter
    def nb_items(self, value: int):
        self._nb_items = value

    @nb_valid_wp.setter
    def nb_valid_wp(self, value: int):
        self._nb_valid_wp = value

    @database_id.setter
    def database_id(self, value: int):
        self._database_id = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._start_wp_id = val[0]
        self._nb_items = check_valid(val[1], 65535, 0)
        self._nb_valid_wp = val[2]
        self._database_id = val[3]
        start_byte += 10
        for i in range(0, self.nb_items):
            dec_obj, start_byte = self.Wp_DefinitionsClass().decode_payload(payload, start_byte)
            self._WP_definitions.append(dec_obj)

        return self, start_byte

    def encode_payload(self) -> bytearray:
        buf_size = self.DEFAULT_BUFFER_SIZE
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = 0xffff
        self._struct_str_0.pack_into(buffer, start_byte, self._start_wp_id, self._nb_items, self._nb_valid_wp, self._database_id, v0)
        start_byte += 10
        for repeat_field in self._WP_definitions:
            start_byte = repeat_field.encode_payload(buffer, start_byte)

        return buffer[:start_byte]

    def from_protobuf(self, message: Pgn130074ClassPb):
        self._start_wp_id = message.start_wp_id
        self._nb_items = message.nb_items
        self._nb_valid_wp = message.nb_valid_wp
        self._database_id = message.database_id
        for sub_set in message.WP_definitions:
            self._WP_definitions.append(self.Wp_DefinitionsClass(protobuf=sub_set))
        self.nb_items = len(self._WP_definitions)

    def as_protobuf(self) -> Pgn130074ClassPb:
        message = Pgn130074ClassPb()
        message.start_wp_id = self._start_wp_id
        message.nb_items = self._nb_items
        message.nb_valid_wp = self._nb_valid_wp
        message.database_id = self._database_id
        for sub_set in self._WP_definitions:
            message.WP_definitions.append(sub_set.as_protobuf())
        self.nb_items = len(self._WP_definitions)
        return message

    def set_protobuf(self, message: Pgn130074ClassPb):
        message.start_wp_id = self._start_wp_id
        message.nb_items = self._nb_items
        message.nb_valid_wp = self._nb_valid_wp
        message.database_id = self._database_id
        for sub_set in self._WP_definitions:
            message.WP_definitions.append(sub_set.as_protobuf())
        self.nb_items = len(self._WP_definitions)

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130074ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [start_wp_id={self._start_wp_id}, nb_items={self._nb_items}, nb_valid_wp={self._nb_valid_wp}, database_id={self._database_id}, WP_definitions={self._WP_definitions}]'


class Pgn130306Class(NMEA2000DecodedMsg):

    _pgn = 130306
    _name = 'Wind Data'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn130306ClassPb

    _struct_str_0 = struct.Struct('<BhHHB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_wind_speed', '_wind_angle', '_reference')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _reference_enum = {
        0: 'True (referenced to North)',
        1: 'Magnetic',
        2: 'Apparent',
        3: 'True (boat referenced)',
        4: 'True (water referenced)',
        6: 'Error',
        7: 'Unavailable'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        FloatFormatter('_wind_speed', 'Wind Speed', '{:.2f}'),
        FloatFormatter('_wind_angle', 'Wind Angle', '{:.4f}'),
        EnumFormatter('_reference', 'Reference', 0x7, local = _reference_enum )
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def wind_speed(self) -> float:
        return self._wind_speed

    @property
    def wind_angle(self) -> float:
        return self._wind_angle

    @property
    def reference(self) -> int:
        return self._reference

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @wind_speed.setter
    def wind_speed(self, value: float):
        self._wind_speed = value

    @wind_angle.setter
    def wind_angle(self, value: float):
        self._wind_angle = value

    @reference.setter
    def reference(self, value: int):
        self._reference = value

    @property
    def reference_text(self) -> str:
        return self._reference_enum.get(self._reference, 'reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._wind_speed = check_convert_float(val[1], 0x7fff, 0.01)
        self._wind_angle = check_convert_float(val[2], 0xffff, 0.0001)
        word = val[3] + (val[4] << 16)
        self._reference = word & 0x7
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._wind_speed, 0x7fff, 0.01)
        v1 = convert_to_int(self._wind_angle, 0xffff, 0.0001)
        word = (self._reference & 0x7) << 0
        word |= 0x1fffff << 3
        v2 = word & 0xFFFF
        v3 = (word & 0xFF) >> 16
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn130306ClassPb):
        self._sequence_id = message.sequence_id
        self._wind_speed = message.wind_speed
        self._wind_angle = message.wind_angle
        self._reference = message.reference

    def as_protobuf(self) -> Pgn130306ClassPb:
        message = Pgn130306ClassPb()
        message.sequence_id = self._sequence_id
        message.wind_speed = self._wind_speed
        message.wind_angle = self._wind_angle
        message.reference = self._reference
        return message

    def set_protobuf(self, message: Pgn130306ClassPb):
        message.sequence_id = self._sequence_id
        message.wind_speed = self._wind_speed
        message.wind_angle = self._wind_angle
        message.reference = self._reference

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130306ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, wind_speed={self._wind_speed}, wind_angle={self._wind_angle}, reference={self._reference}]'


class Pgn130310Class(NMEA2000DecodedMsg):

    _pgn = 130310
    _name = 'Environmental Parameters'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn130310ClassPb

    _struct_str_0 = struct.Struct('<BHHHB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_water_temperature', '_outside_air_temperature', '_atmospheric_pressure')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        FloatFormatter('_water_temperature', 'Water Temperature', '{:.1f}'),
        FloatFormatter('_outside_air_temperature', 'Outside Ambient Air Temperature', '{:.1f}'),
        FloatFormatter('_atmospheric_pressure', 'Atmospheric Pressure', '{:.0f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def water_temperature(self) -> float:
        return self._water_temperature

    @property
    def outside_air_temperature(self) -> float:
        return self._outside_air_temperature

    @property
    def atmospheric_pressure(self) -> float:
        return self._atmospheric_pressure

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @water_temperature.setter
    def water_temperature(self, value: float):
        self._water_temperature = value

    @outside_air_temperature.setter
    def outside_air_temperature(self, value: float):
        self._outside_air_temperature = value

    @atmospheric_pressure.setter
    def atmospheric_pressure(self, value: float):
        self._atmospheric_pressure = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._water_temperature = check_convert_float(val[1], 0xffff, 0.01)
        self._outside_air_temperature = check_convert_float(val[2], 0xffff, 0.01)
        self._atmospheric_pressure = check_convert_float(val[3], 0xffff, 100.0)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._water_temperature, 0xffff, 0.01)
        v1 = convert_to_int(self._outside_air_temperature, 0xffff, 0.01)
        v2 = convert_to_int(self._atmospheric_pressure, 0xffff, 100.0)
        v3 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn130310ClassPb):
        self._sequence_id = message.sequence_id
        self._water_temperature = message.water_temperature
        self._outside_air_temperature = message.outside_air_temperature
        self._atmospheric_pressure = message.atmospheric_pressure

    def as_protobuf(self) -> Pgn130310ClassPb:
        message = Pgn130310ClassPb()
        message.sequence_id = self._sequence_id
        message.water_temperature = self._water_temperature
        message.outside_air_temperature = self._outside_air_temperature
        message.atmospheric_pressure = self._atmospheric_pressure
        return message

    def set_protobuf(self, message: Pgn130310ClassPb):
        message.sequence_id = self._sequence_id
        message.water_temperature = self._water_temperature
        message.outside_air_temperature = self._outside_air_temperature
        message.atmospheric_pressure = self._atmospheric_pressure

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130310ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, water_temperature={self._water_temperature}, outside_air_temperature={self._outside_air_temperature}, atmospheric_pressure={self._atmospheric_pressure}]'


class Pgn130311Class(NMEA2000DecodedMsg):

    _pgn = 130311
    _name = 'Environmental Parameters'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn130311ClassPb

    _struct_str_0 = struct.Struct('<BBHhH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_temperature_instance', '_humidity_instance', '_temperature', '_humidity', '_atmospheric_pressure')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _temperature_instance_enum = {
        0: 'Sea Temperature',
        1: 'Outside Temperature',
        2: 'Inside Temperature',
        3: 'Engine Room Temperature',
        4: 'Main Cabin Temperature'
        }
    _humidity_instance_enum = {
        0: 'Inside',
        1: 'Outside'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        EnumFormatter('_temperature_instance', 'Temperature Instance', 0x3f, local = _temperature_instance_enum ),
        EnumFormatter('_humidity_instance', 'Humidity Instance', 0x3, local = _humidity_instance_enum ),
        FloatFormatter('_temperature', 'Temperature', '{:.1f}'),
        FloatFormatter('_humidity', 'Humidity', '{:.0f}'),
        FloatFormatter('_atmospheric_pressure', 'Atmospheric Pressure', '{:.0f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def temperature_instance(self) -> int:
        return self._temperature_instance

    @property
    def humidity_instance(self) -> int:
        return self._humidity_instance

    @property
    def temperature(self) -> float:
        return self._temperature

    @property
    def humidity(self) -> float:
        return self._humidity

    @property
    def atmospheric_pressure(self) -> float:
        return self._atmospheric_pressure

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @temperature_instance.setter
    def temperature_instance(self, value: int):
        self._temperature_instance = value

    @humidity_instance.setter
    def humidity_instance(self, value: int):
        self._humidity_instance = value

    @temperature.setter
    def temperature(self, value: float):
        self._temperature = value

    @humidity.setter
    def humidity(self, value: float):
        self._humidity = value

    @atmospheric_pressure.setter
    def atmospheric_pressure(self, value: float):
        self._atmospheric_pressure = value

    @property
    def temperature_instance_text(self) -> str:
        return self._temperature_instance_enum.get(self._temperature_instance, 'temperature_instance key error')

    @property
    def humidity_instance_text(self) -> str:
        return self._humidity_instance_enum.get(self._humidity_instance, 'humidity_instance key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._temperature_instance = val[1] & 0x3F
        self._humidity_instance = (val[1] >> 6) & 0x3
        self._temperature = check_convert_float(val[2], 0xffff, 0.01)
        self._humidity = check_convert_float(val[3], 0x7fff, 0.004)
        self._atmospheric_pressure = check_convert_float(val[4], 0xffff, 100.0)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._temperature_instance & 0x3f) << 0
        v0 |= (self._humidity_instance & 0x3) << 6
        v1 = convert_to_int(self._temperature, 0xffff, 0.01)
        v2 = convert_to_int(self._humidity, 0x7fff, 0.004)
        v3 = convert_to_int(self._atmospheric_pressure, 0xffff, 100.0)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn130311ClassPb):
        self._sequence_id = message.sequence_id
        self._temperature_instance = message.temperature_instance
        self._humidity_instance = message.humidity_instance
        self._temperature = message.temperature
        self._humidity = message.humidity
        self._atmospheric_pressure = message.atmospheric_pressure

    def as_protobuf(self) -> Pgn130311ClassPb:
        message = Pgn130311ClassPb()
        message.sequence_id = self._sequence_id
        message.temperature_instance = self._temperature_instance
        message.humidity_instance = self._humidity_instance
        message.temperature = self._temperature
        message.humidity = self._humidity
        message.atmospheric_pressure = self._atmospheric_pressure
        return message

    def set_protobuf(self, message: Pgn130311ClassPb):
        message.sequence_id = self._sequence_id
        message.temperature_instance = self._temperature_instance
        message.humidity_instance = self._humidity_instance
        message.temperature = self._temperature
        message.humidity = self._humidity
        message.atmospheric_pressure = self._atmospheric_pressure

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130311ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, temperature_instance={self._temperature_instance}, humidity_instance={self._humidity_instance}, temperature={self._temperature}, humidity={self._humidity}, atmospheric_pressure={self._atmospheric_pressure}]'


class Pgn130312Class(NMEA2000DecodedMsg):

    _pgn = 130312
    _name = 'Temperature'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn130312ClassPb

    _struct_str_0 = struct.Struct('<BBBHHB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_temperature_instance', '_temperature_source', '_actual_temperature', '_set_temperature')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _temperature_source_enum = 'Temperature Source'
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        GenericFormatter('_temperature_instance', 'Temperature Instance', 0xff),
        EnumFormatter('_temperature_source', 'Temperature Source', 0xff, global_enum ='Temperature Source' ),
        FloatFormatter('_actual_temperature', 'Actual Temperature', '{:.1f}'),
        FloatFormatter('_set_temperature', 'Set Temperature', '{:.1f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def temperature_instance(self) -> int:
        return self._temperature_instance

    @property
    def temperature_source(self) -> int:
        return self._temperature_source

    @property
    def actual_temperature(self) -> float:
        return self._actual_temperature

    @property
    def set_temperature(self) -> float:
        return self._set_temperature

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @temperature_instance.setter
    def temperature_instance(self, value: int):
        self._temperature_instance = value

    @temperature_source.setter
    def temperature_source(self, value: int):
        self._temperature_source = value

    @actual_temperature.setter
    def actual_temperature(self, value: float):
        self._actual_temperature = value

    @set_temperature.setter
    def set_temperature(self, value: float):
        self._set_temperature = value

    @property
    def temperature_source_text(self) -> str:
        return resolve_global_enum(self._temperature_source_enum, self._temperature_source)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._temperature_instance = val[1]
        self._temperature_source = val[2]
        self._actual_temperature = check_convert_float(val[3], 0xffff, 0.01)
        self._set_temperature = check_convert_float(val[4], 0xffff, 0.01)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._actual_temperature, 0xffff, 0.01)
        v1 = convert_to_int(self._set_temperature, 0xffff, 0.01)
        v2 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, self._temperature_instance, self._temperature_source, v0, v1, v2)
        return buffer

    def from_protobuf(self, message: Pgn130312ClassPb):
        self._sequence_id = message.sequence_id
        self._temperature_instance = message.temperature_instance
        self._temperature_source = message.temperature_source
        self._actual_temperature = message.actual_temperature
        self._set_temperature = message.set_temperature

    def as_protobuf(self) -> Pgn130312ClassPb:
        message = Pgn130312ClassPb()
        message.sequence_id = self._sequence_id
        message.temperature_instance = self._temperature_instance
        message.temperature_source = self._temperature_source
        message.actual_temperature = self._actual_temperature
        message.set_temperature = self._set_temperature
        return message

    def set_protobuf(self, message: Pgn130312ClassPb):
        message.sequence_id = self._sequence_id
        message.temperature_instance = self._temperature_instance
        message.temperature_source = self._temperature_source
        message.actual_temperature = self._actual_temperature
        message.set_temperature = self._set_temperature

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130312ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, temperature_instance={self._temperature_instance}, temperature_source={self._temperature_source}, actual_temperature={self._actual_temperature}, set_temperature={self._set_temperature}]'


class Pgn130314Class(NMEA2000DecodedMsg):

    _pgn = 130314
    _name = 'Actual Pressure'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn130314ClassPb

    _struct_str_0 = struct.Struct('<BBBIB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_pressure_instance', '_pressure_source', '_pressure')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _pressure_source_enum = {
        0: 'Atmospheric',
        1: 'Water',
        2: 'Steam',
        3: 'Compressed Air',
        4: 'Hydraulic'
        }
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        GenericFormatter('_pressure_instance', 'Pressure Instance', 0xff),
        EnumFormatter('_pressure_source', 'Pressure Source', 0xff, local = _pressure_source_enum ),
        FloatFormatter('_pressure', 'Pressure', '{:.0f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def pressure_instance(self) -> int:
        return self._pressure_instance

    @property
    def pressure_source(self) -> int:
        return self._pressure_source

    @property
    def pressure(self) -> float:
        return self._pressure

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @pressure_instance.setter
    def pressure_instance(self, value: int):
        self._pressure_instance = value

    @pressure_source.setter
    def pressure_source(self, value: int):
        self._pressure_source = value

    @pressure.setter
    def pressure(self, value: float):
        self._pressure = value

    @property
    def pressure_source_text(self) -> str:
        return self._pressure_source_enum.get(self._pressure_source, 'pressure_source key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._pressure_instance = val[1]
        self._pressure_source = val[2]
        self._pressure = check_convert_float(val[3], 0xffffffff, 0.1)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._pressure, 0xffffffff, 0.1)
        v1 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, self._pressure_instance, self._pressure_source, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn130314ClassPb):
        self._sequence_id = message.sequence_id
        self._pressure_instance = message.pressure_instance
        self._pressure_source = message.pressure_source
        self._pressure = message.pressure

    def as_protobuf(self) -> Pgn130314ClassPb:
        message = Pgn130314ClassPb()
        message.sequence_id = self._sequence_id
        message.pressure_instance = self._pressure_instance
        message.pressure_source = self._pressure_source
        message.pressure = self._pressure
        return message

    def set_protobuf(self, message: Pgn130314ClassPb):
        message.sequence_id = self._sequence_id
        message.pressure_instance = self._pressure_instance
        message.pressure_source = self._pressure_source
        message.pressure = self._pressure

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130314ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, pressure_instance={self._pressure_instance}, pressure_source={self._pressure_source}, pressure={self._pressure}]'


class Pgn130316Class(NMEA2000DecodedMsg):

    _pgn = 130316
    _name = 'Temperature Extended Range'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn130316ClassPb

    _struct_str_0 = struct.Struct('<BBBHBH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_sequence_id', '_temperature_instance', '_temperature_source', '_actual_temperature', '_set_temperature')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _temperature_source_enum = 'Temperature Source'
    _json_format = (
        GenericFormatter('_sequence_id', 'SID', 0xff),
        GenericFormatter('_temperature_instance', 'Temperature Instance', 0xff),
        EnumFormatter('_temperature_source', 'Temperature Source', 0xff, global_enum ='Temperature Source' ),
        FloatFormatter('_actual_temperature', 'Actual Temperature', '{:.1f}'),
        FloatFormatter('_set_temperature', 'Set Temperature', '{:.1f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def sequence_id(self) -> int:
        return self._sequence_id

    @property
    def temperature_instance(self) -> int:
        return self._temperature_instance

    @property
    def temperature_source(self) -> int:
        return self._temperature_source

    @property
    def actual_temperature(self) -> float:
        return self._actual_temperature

    @property
    def set_temperature(self) -> float:
        return self._set_temperature

    @sequence_id.setter
    def sequence_id(self, value: int):
        self._sequence_id = value

    @temperature_instance.setter
    def temperature_instance(self, value: int):
        self._temperature_instance = value

    @temperature_source.setter
    def temperature_source(self, value: int):
        self._temperature_source = value

    @actual_temperature.setter
    def actual_temperature(self, value: float):
        self._actual_temperature = value

    @set_temperature.setter
    def set_temperature(self, value: float):
        self._set_temperature = value

    @property
    def temperature_source_text(self) -> str:
        return resolve_global_enum(self._temperature_source_enum, self._temperature_source)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._sequence_id = val[0]
        self._temperature_instance = val[1]
        self._temperature_source = val[2]
        word = val[3] + (val[4] << 16)
        self._actual_temperature = check_convert_float(word, 0xffffff, 0.001)
        self._set_temperature = check_convert_float(val[5], 0xffff, 0.1)
        start_byte += 8
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        word = convert_to_int(self._actual_temperature, 0xffffff, 0.001)
        v0 = word & 0xffff
        v1 = (word >> 16) & 0xff
        v2 = convert_to_int(self._set_temperature, 0xffff, 0.1)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._sequence_id, self._temperature_instance, self._temperature_source, v0, v1, v2)
        return buffer

    def from_protobuf(self, message: Pgn130316ClassPb):
        self._sequence_id = message.sequence_id
        self._temperature_instance = message.temperature_instance
        self._temperature_source = message.temperature_source
        self._actual_temperature = message.actual_temperature
        self._set_temperature = message.set_temperature

    def as_protobuf(self) -> Pgn130316ClassPb:
        message = Pgn130316ClassPb()
        message.sequence_id = self._sequence_id
        message.temperature_instance = self._temperature_instance
        message.temperature_source = self._temperature_source
        message.actual_temperature = self._actual_temperature
        message.set_temperature = self._set_temperature
        return message

    def set_protobuf(self, message: Pgn130316ClassPb):
        message.sequence_id = self._sequence_id
        message.temperature_instance = self._temperature_instance
        message.temperature_source = self._temperature_source
        message.actual_temperature = self._actual_temperature
        message.set_temperature = self._set_temperature

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130316ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [sequence_id={self._sequence_id}, temperature_instance={self._temperature_instance}, temperature_source={self._temperature_source}, actual_temperature={self._actual_temperature}, set_temperature={self._set_temperature}]'


class Pgn130578Class(NMEA2000DecodedMsg):

    _pgn = 130578
    _name = 'Vessel Speed Components'
    _proprietary = False

    @staticmethod
    def protobuf_class():
        return Pgn130578ClassPb

    _struct_str_0 = struct.Struct('<hhhhhh')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_longitudinal_speed_water', '_transverse_speed_water', '_longitudinal_speed_ground', '_transverse_speed_ground', '_stern_speed_water', '_stern_speed_ground')

    _static_size = 12

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _json_format = (
        FloatFormatter('_longitudinal_speed_water', 'Longitudinal Speed, Water-referenced', '{:.2f}'),
        FloatFormatter('_transverse_speed_water', 'Transverse Speed, Water-referenced', '{:.2f}'),
        FloatFormatter('_longitudinal_speed_ground', 'Longitudinal Speed, Ground-referenced', '{:.2f}'),
        FloatFormatter('_transverse_speed_ground', 'Transverse Speed, Ground-referenced', '{:.2f}'),
        FloatFormatter('_stern_speed_water', 'Stern Speed, Water-referenced', '{:.2f}'),
        FloatFormatter('_stern_speed_ground', 'Stern Speed, Ground-referenced', '{:.2f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def longitudinal_speed_water(self) -> float:
        return self._longitudinal_speed_water

    @property
    def transverse_speed_water(self) -> float:
        return self._transverse_speed_water

    @property
    def longitudinal_speed_ground(self) -> float:
        return self._longitudinal_speed_ground

    @property
    def transverse_speed_ground(self) -> float:
        return self._transverse_speed_ground

    @property
    def stern_speed_water(self) -> float:
        return self._stern_speed_water

    @property
    def stern_speed_ground(self) -> float:
        return self._stern_speed_ground

    @longitudinal_speed_water.setter
    def longitudinal_speed_water(self, value: float):
        self._longitudinal_speed_water = value

    @transverse_speed_water.setter
    def transverse_speed_water(self, value: float):
        self._transverse_speed_water = value

    @longitudinal_speed_ground.setter
    def longitudinal_speed_ground(self, value: float):
        self._longitudinal_speed_ground = value

    @transverse_speed_ground.setter
    def transverse_speed_ground(self, value: float):
        self._transverse_speed_ground = value

    @stern_speed_water.setter
    def stern_speed_water(self, value: float):
        self._stern_speed_water = value

    @stern_speed_ground.setter
    def stern_speed_ground(self, value: float):
        self._stern_speed_ground = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._longitudinal_speed_water = check_convert_float(val[0], 0x7fff, 0.001)
        self._transverse_speed_water = check_convert_float(val[1], 0x7fff, 0.001)
        self._longitudinal_speed_ground = check_convert_float(val[2], 0x7fff, 0.001)
        self._transverse_speed_ground = check_convert_float(val[3], 0x7fff, 0.001)
        self._stern_speed_water = check_convert_float(val[4], 0x7fff, 0.001)
        self._stern_speed_ground = check_convert_float(val[5], 0x7fff, 0.001)
        start_byte += 12
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = convert_to_int(self._longitudinal_speed_water, 0x7fff, 0.001)
        v1 = convert_to_int(self._transverse_speed_water, 0x7fff, 0.001)
        v2 = convert_to_int(self._longitudinal_speed_ground, 0x7fff, 0.001)
        v3 = convert_to_int(self._transverse_speed_ground, 0x7fff, 0.001)
        v4 = convert_to_int(self._stern_speed_water, 0x7fff, 0.001)
        v5 = convert_to_int(self._stern_speed_ground, 0x7fff, 0.001)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, v1, v2, v3, v4, v5)
        return buffer

    def from_protobuf(self, message: Pgn130578ClassPb):
        self._longitudinal_speed_water = message.longitudinal_speed_water
        self._transverse_speed_water = message.transverse_speed_water
        self._longitudinal_speed_ground = message.longitudinal_speed_ground
        self._transverse_speed_ground = message.transverse_speed_ground
        self._stern_speed_water = message.stern_speed_water
        self._stern_speed_ground = message.stern_speed_ground

    def as_protobuf(self) -> Pgn130578ClassPb:
        message = Pgn130578ClassPb()
        message.longitudinal_speed_water = self._longitudinal_speed_water
        message.transverse_speed_water = self._transverse_speed_water
        message.longitudinal_speed_ground = self._longitudinal_speed_ground
        message.transverse_speed_ground = self._transverse_speed_ground
        message.stern_speed_water = self._stern_speed_water
        message.stern_speed_ground = self._stern_speed_ground
        return message

    def set_protobuf(self, message: Pgn130578ClassPb):
        message.longitudinal_speed_water = self._longitudinal_speed_water
        message.transverse_speed_water = self._transverse_speed_water
        message.longitudinal_speed_ground = self._longitudinal_speed_ground
        message.transverse_speed_ground = self._transverse_speed_ground
        message.stern_speed_water = self._stern_speed_water
        message.stern_speed_ground = self._stern_speed_ground

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130578ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [longitudinal_speed_water={self._longitudinal_speed_water}, transverse_speed_water={self._transverse_speed_water}, longitudinal_speed_ground={self._longitudinal_speed_ground}, transverse_speed_ground={self._transverse_speed_ground}, stern_speed_water={self._stern_speed_water}, stern_speed_ground={self._stern_speed_ground}]'


class Pgn130842Mfg1857Class(NMEA2000DecodedMsg):

    _pgn = 130842
    _name = 'Simnet: AIS Class B static data (msg 24 Part B)'
    _proprietary = True
    _manufacturer_id = 1857

    @staticmethod
    def protobuf_class():
        return Pgn130842Mfg1857ClassPb

    _struct_str_0 = struct.Struct('<HBBBiB')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<hhh')
    _struct_str_1_size = _struct_str_1.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_type_of_ship', '_vendor_id', '_call_sign', '_length', '_beam', '_position_from_starboard')

    _static_size = 30

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = 'AIS Repeat Indicator'
    _type_of_ship_enum = 'Type of ship'
    _json_format = (
        GenericFormatter('_message_id', 'Message ID', 0x3f),
        EnumFormatter('_repeat_indicator', 'Repeat indicator', 0x3, global_enum ='AIS Repeat Indicator' ),
        GenericFormatter('_mmsi', 'User ID', 0x7fffffff),
        EnumFormatter('_type_of_ship', 'Type of ship', 0xff, global_enum ='Type of ship' ),
        TextFormatter('_vendor_id', 'Vendor ID'),
        TextFormatter('_call_sign', 'Callsign'),
        FloatFormatter('_length', 'Length', '{:.1f}'),
        FloatFormatter('_beam', 'Beam', '{:.1f}'),
        FloatFormatter('_position_from_starboard', 'Position reference from Starboard', '{:.1f}')
        )

    def json_format(self):
        return self._json_format

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def manufacturer_id(self) -> int:
        return self._manufacturer_id

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def type_of_ship(self) -> int:
        return self._type_of_ship

    @property
    def vendor_id(self) -> str:
        return self._vendor_id

    @property
    def call_sign(self) -> str:
        return self._call_sign

    @property
    def length(self) -> float:
        return self._length

    @property
    def beam(self) -> float:
        return self._beam

    @property
    def position_from_starboard(self) -> float:
        return self._position_from_starboard

    @message_id.setter
    def message_id(self, value: int):
        self._message_id = value

    @repeat_indicator.setter
    def repeat_indicator(self, value: int):
        self._repeat_indicator = value

    @mmsi.setter
    def mmsi(self, value: int):
        self._mmsi = value

    @type_of_ship.setter
    def type_of_ship(self, value: int):
        self._type_of_ship = value

    @vendor_id.setter
    def vendor_id(self, value: str):
        self._vendor_id = value

    @call_sign.setter
    def call_sign(self, value: str):
        self._call_sign = value

    @length.setter
    def length(self, value: float):
        self._length = value

    @beam.setter
    def beam(self, value: float):
        self._beam = value

    @position_from_starboard.setter
    def position_from_starboard(self, value: float):
        self._position_from_starboard = value

    @property
    def repeat_indicator_text(self) -> str:
        return resolve_global_enum(self._repeat_indicator_enum, self._repeat_indicator)

    @property
    def type_of_ship_text(self) -> str:
        return resolve_global_enum(self._type_of_ship_enum, self._type_of_ship)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, start_byte)
        self._message_id = val[1] & 0x3F
        self._repeat_indicator = (val[1] >> 6) & 0x3
        self._mmsi = val[4]
        self._type_of_ship = val[5]
        start_byte += 10
        self._vendor_id = clean_string(payload[start_byte: start_byte + 7])
        start_byte += 7
        self._call_sign = clean_string(payload[start_byte: start_byte + 7])
        start_byte += 7
        val = self._struct_str_1.unpack_from(payload, start_byte)
        self._length = check_convert_float(val[0], 0x7fff, 0.1)
        self._beam = check_convert_float(val[1], 0x7fff, 0.1)
        self._position_from_starboard = check_convert_float(val[2], 0x7fff, 0.1)
        start_byte += 6
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = 0x7ff << 0
        v0 |= 0x3 << 11
        v0 |= 0x7 << 13
        v1 = (self._message_id & 0x3f) << 0
        v1 |= (self._repeat_indicator & 0x3) << 6
        v2 = 0xff
        v3 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, v1, v2, v3, self._mmsi, self._type_of_ship)
        insert_string(buffer, 10 + start_byte, 7, self._vendor_id)
        insert_string(buffer, 17 + start_byte, 7, self._call_sign)
        v0 = convert_to_int(self._length, 0x7fff, 0.1)
        v1 = convert_to_int(self._beam, 0x7fff, 0.1)
        v2 = convert_to_int(self._position_from_starboard, 0x7fff, 0.1)
        self._struct_str_1.pack_into(buffer, 24 + start_byte, v0, v1, v2)
        return buffer

    def from_protobuf(self, message: Pgn130842Mfg1857ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._type_of_ship = message.type_of_ship
        self._vendor_id = message.vendor_id
        self._call_sign = message.call_sign
        self._length = message.length
        self._beam = message.beam
        self._position_from_starboard = message.position_from_starboard

    def as_protobuf(self) -> Pgn130842Mfg1857ClassPb:
        message = Pgn130842Mfg1857ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.type_of_ship = self._type_of_ship
        message.vendor_id = self._vendor_id
        message.call_sign = self._call_sign
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard
        return message

    def set_protobuf(self, message: Pgn130842Mfg1857ClassPb):
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.type_of_ship = self._type_of_ship
        message.vendor_id = self._vendor_id
        message.call_sign = self._call_sign
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130842Mfg1857ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, type_of_ship={self._type_of_ship}, vendor_id={self._vendor_id}, call_sign={self._call_sign}, length={self._length}, beam={self._beam}, position_from_starboard={self._position_from_starboard}]'


#####################################################################
#         Generated class dictionary
#####################################################################
nmea2k_generated_classes = {
        65359: Pgn65359Mfg1851Class,
        65379: Pgn65379Mfg1851Class,
        126992: Pgn126992Class,
        127245: Pgn127245Class,
        127250: Pgn127250Class,
        127258: Pgn127258Class,
        127488: Pgn127488Class,
        127489: Pgn127489Class,
        127507: Pgn127507Class,
        127508: Pgn127508Class,
        127751: Pgn127751Class,
        128259: Pgn128259Class,
        128267: Pgn128267Class,
        128275: Pgn128275Class,
        129025: Pgn129025Class,
        129026: Pgn129026Class,
        129029: Pgn129029Class,
        129038: Pgn129038Class,
        129039: Pgn129039Class,
        129283: Pgn129283Class,
        129284: Pgn129284Class,
        129285: Pgn129285Class,
        129539: Pgn129539Class,
        129540: Pgn129540Class,
        129794: Pgn129794Class,
        129809: Pgn129809Class,
        129810: Pgn129810Class,
        130074: Pgn130074Class,
        130306: Pgn130306Class,
        130310: Pgn130310Class,
        130311: Pgn130311Class,
        130312: Pgn130312Class,
        130314: Pgn130314Class,
        130316: Pgn130316Class,
        130578: Pgn130578Class,
        130842: Pgn130842Mfg1857Class
        }
# end of generated file
